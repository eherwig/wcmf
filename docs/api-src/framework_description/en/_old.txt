C O N F I G U R A T I O N
=========================

\subsubsection secconfig [config]
This section refers to the configuration files. The following keys are known to the framework::

~~~~~~~~~~~~~{.ini}
include          = array with configuration files
                 ; allows the inclusion of further configuration files
                 ; (Included values don't overwrite the current)
                 ; used in: class.InifileParser.php
hiddenSections   = array with sections
                 ; allows the hiding of sections in the admintool
                 ; used in: class.InifileParser.php
readonlySections = array with sections
                 ; allows the protection of sections in the admintool
                 ; used in: class.InifileParser.php
~~~~~~~~~~~~~

\subsubsection secclassmapping [classmapping]
Since %Controller, %PersistenceMapper and other classes in the configuration file's sections are only
labeled with their classnames, the framework needs information, in which files the class definitions can be
found. In the section @em classmapping therefore a corresponding definition file for each class is given.

~~~~~~~~~~~~~{.ini}
classname = path_to/classfilename
~~~~~~~~~~~~~

\subsubsection sectypemapping [typemapping]
The relation between domain classes and their PersistenceMappers (see \ref persistence) is set in the
section @em typemapping. A @em * as key means that all types, which are not specified, will be handled by
the assigned %PersistenceMapper. The PersistenceFacade uses these information to find the appropriate
%PersistenceMapper classes for the domain classes.

~~~~~~~~~~~~~{.ini}
type = mapperClass
~~~~~~~~~~~~~

\subsubsection secimplementation [implementation]
In some cases the framework offers different implementations for abstract classes. At the moment this refers
to basic services, which access the data storage (database, XML), e.g. AuthUser. The implementation, which
should be used by the framework can be specified in this section. For the following classes an implementation
can be chosen:

~~~~~~~~~~~~~{.ini}
LockManager = LockManagerRDB|BusyLockManager|NullLockManager
UserManager = UserManagerRDB|UserManagerXML
User = UserRDB|UserXML
Role = RoleRDB|RoleXML
UserRole = NMUserRole
View = View|NullView
ControlRenderer = DefaultControlRenderer
ValueRenderer = DefaultValueRenderer
HTMLFormat = HTMLFormat
JSONFormat = JSONFormat
SOAPFormat = SOAPFormat
~~~~~~~~~~~~~

Furthermore this mechanism allows developers to provide own implementations of the abstract classes.

\subsubsection secinitparams [initparams]
Since some classes require specific parameters in their constructors (e.g. database connection),
these parameters can be grouped in sections (e.g. @em [database]) and referenced in the section
@em initparams. The keys are the classnames and the values the corresponding parameter sections.
The key-value pairs of the parameter section will be passed as associative array to the constructor
upon creation of the objects.

~~~~~~~~~~~~~{.ini}
class = initsection
~~~~~~~~~~~~~

\subsubsection secconverter [converter]
In this section DataConverters for types are configured (see \ref persistence):

~~~~~~~~~~~~~{.ini}
type = converterClass
~~~~~~~~~~~~~

\subsubsection secactionmapping [actionmapping]
In the section @em actionmapping the actual application flow is defined. This is achieved by defining
the transition from one controller to the next.@n
The key is an action key (see \ref actionkey), which clearly describes the state the application is
in before the transition. The value sets the next controller to execute. The ActionMapper uses this
information to determine which Controller is executed next.

~~~~~~~~~~~~~{.ini}
controllerA?context?action = controllerB
~~~~~~~~~~~~~

\subsubsection secviews [views]
For each controller a view can be defined dependent on its context and action, which is described
by its Smarty template (.tpl file). In the section @em views each action key can have a view template
assigned (see \ref actionkey). The controller uses this information to determine its view.

~~~~~~~~~~~~~{.ini}
controllerA?context?action = view
~~~~~~~~~~~~~

\subsubsection secauthorization [authorization]
The Authorization is based on action keys (see \ref actionkey), whereby the following actions can be
defined by the individual parts of the key:

~~~~~~~~~~~~~{.ini}
controller?context?action ; an action in the application flow
type?context?action       ; an action on a domain class (read, update, delete, create)
oid?context?action        ; an action on a domain object (read, update, delete, create)
~~~~~~~~~~~~~

To each of these actions different roles can be assigned (comma separated), for which a permission
is granted (@em +) or denied (@em -). The role @em * stands for all roles.@n
If a permission is not explicitly granted, it is considered as denied. For not listed Aktion Keys the
decision is made by the _defaultPolicy of the AuthUser. The RightsManager uses this information to
authorize an AuthUser for an action.

The following code shows an example, where the creation of Category instances is only allowed for users having
the @em administrators role:

~~~~~~~~~~~~~{.ini}
Category??create = -authors +administrators
~~~~~~~~~~~~~

\subsubsection secroleconfig [roleconfig]
Allows auto assignment of an additional configuration file for different user roles. If a user is added
to a listed role, then the given configuration file will be automatically assigned by the UserManager
(see also \ref userconfig).

~~~~~~~~~~~~~{.ini}
rolename = configurationfile
~~~~~~~~~~~~~

For example if users of the @em administrators role should always use the admin.ini configuration file
you could add the following entry:

~~~~~~~~~~~~~{.ini}
administrators = admin.ini
~~~~~~~~~~~~~

\subsubsection seccms [cms]
This section refers to the general application configuration. The following keys are known to the framework::

~~~~~~~~~~~~~{.ini}
applicationTitle = application title
                 ; specifies the title which appears in the default application
                 ; used in: class.Controller.php, locale.php
rootTypes        = array of domain classes
                 ; declaration of types, which don't have parent types to allow them to be created
                 ; on the top level of the default application
                 ; used in: class.DisplayController.php, class.TreeViewController.php,
                 ;               class.XMLExportController.php, graph.php
anonymous        = 0|1
                 ; indicates, if the user must authenticate himself upon application start.
                 ; If the value is 1 the rights management is also disabled.
                 ; used in: class.LoginController.php, class.RightsManager.php
exportDir        = path (relative to main.php !)
                 ; sets the root directory for the export of static pages
                 ; used in: class.PageExportController.php
htmlBaseDir      = path (relative to main.php !)
                 ; sets the root directory for the html output
                 ; used in: class.LinkConverter.php
backupDir        = path (relative to main.php !)
                 ; sets the root directory for backups
                 ; used in: class.BackupController.php
libDir           = path (relative to main.php !)
                 ; sets the root directory of the framework
                 ; used in: class.TreeViewController.php, resource.lib.php, class.FormUtil.php
localeDir        = path (relative to main.php !)
                 ; sets the language directory of the application
                 ; used in: main.php, class.I18nUtil.php, po2array.php
logDBActions     = 0|1
                 ; specifies, whether database access should be logged in the logfile
                 ; used in: main.php
logSQL           = 0|1
                 ; specifies, whether the logging of the database layer is activated
                 ; ADOdb then logs all access in the table adodb_logsql
                 ; used in: class.NodeRDBMapper.php, class.NodeToSingleTableMapper.php,
                 ;               class.LockManagerRDB.php, class.AuthUserRDB.php, class.UserManagerRDB.php
logExecuteTime   = 0|1
                 ; specifies, whether to log the time each controller needs to execute
                 ; used in: class.ActionMapper.php
debugView        = 0|1
                 ; specifies, whether Smarty should create debug output in a popup window
                 ; used in: class.Controller.php
language         = language code (e.g. en_EN)
                 ; specifies the application's language (see Message::get)
                 ; used in: main.php, locale.php
usegettext       = 0|1
                 ; specifies, whether the function gettext should be used for the localization of the
                 ; application (see Message::get).
                 ; used in: class.Message.php
locking          = 0|1
                 ; specifies, whether data is locked when it's opened by another user
                 ; used in: class.LockManager.php
~~~~~~~~~~~~~

\subsubsection sechtmlform [htmlform]
The definition of the input controls, that are used in the application,
is done in Smarty templates (see \ref DefaultControlRenderer). In this section the templates
are assigned to control names.@n
The following input controls are already defined by the framework:

~~~~~~~~~~~~~
text
textarea
password
select
radio
checkbox
file
fileex
filebrowser
linkbrowser
fckeditor
date
~~~~~~~~~~~~~

Furthermore the following keys are known to the framework:

~~~~~~~~~~~~~{.ini}
maxFileSize             = number
                        ; specifies the maximum size of files to upload (in bytes)
                        ; used in: class.FormUtil.php, class.NodeUtil.php,
                                        class.SaveController.php, class.FileUtil.php
inputFieldNameDelimiter = char
                        ; specifies the separator, which is used for creation of inputfield names
                        ; (e.g. separator "-": "value-1-name-Author:0")
                        ; used in: class.SaveController.php, class.NodeUtil.php,
                                        class.FormUtil.php
~~~~~~~~~~~~~

\subsubsection sechtmldisplay [htmldisplay]
The definition of the value display types, that are used in the application,
is done in Smarty templates (see \ref DefaultValueRenderer). In this section the templates
are assigned to value type names.@n
The following value types are already defined by the framework:

~~~~~~~~~~~~~
text
image
~~~~~~~~~~~~~

\subsubsection secsmarty [smarty]
The @em smarty section contains configuration parameters for the <a href="http://smarty.php.net/" target="_blank">
Smarty</a> Template Engine.

~~~~~~~~~~~~~{.ini}
compileCheck = 0|1
               ; specifies, whether Smarty should test for modifications
               ; in the templates upon each call
               ; used in: class.Controller.php
templateDir  = path (relative to main.php !)
               ; specifies the smarty directory (the paths /smarty/templates_c
               ; and in case of caching=1 /smarty/cache must exist in that directory)
               ; used in: class.Controller.php
caching = 0|1
               ; specifies, whether Smarty should use caching
               ; in case of a cms application caching is a good alternative to exporting
               ; static pages
               ; used in: class.Controller.php
cacheLifetime = -1|number of seconds
               ; specifies, the lifetime of the Smarty cache in seconds
               ; the value is ignored if caching is not enabled
               ; used in: class.Controller.php
~~~~~~~~~~~~~

\subsubsection secmedia [media]
In this section settings for the upload of media files are specified.

~~~~~~~~~~~~~{.ini}
imgWidth  = array of a number and 0|1
          ; sets - if specified - the width of an upload image
          ; the second parameter specifies if the value must be matched exactly (1)
          ; or if it is a maximum (0)
          ; e.g. {625, 0}
          ; used in: class.SaveController.php
imgHeight = array of a number and 0|1
          ; sets - if specified - the height of an upload image
          ; the second parameter specifies if the value must be matched exactly (1)
          ; or if it is a maximum (0)
          ; e.g. {625, 1}
          ; used in: class.SaveController.php
uploadDir = path (relative to main.php !)
          ; specifies the directory, into which the SaveController uploads media files
          ; used in: class.SaveController.php, class.FormUtil.php
~~~~~~~~~~~~~


P R E S E N T A T I O N
=======================

For debugging und logging output the [log4php](http://logging.apache.org/log4php/)
framework is used. For convenient usage wCMF defines a thin wrapper class called Log.
To log a debug message in the category of the current class, just call:

~~~~~~~~~~~~~{.php}
Log::debug($message, __CLASS__);
~~~~~~~~~~~~~

## Error handling ## {#pres_errors}

In the application two types of errors are distinguished:
- **Fatal**: Errors, which are so critical, that it's not possible to proceed with
  the current action (e.g. the missing of a controller).
- **Non-fatal**: Errors, which merely demand a notification to the user (e.g. invalid input)

These errors can be produced in the following ways:

- **Fatal**: The use of WCMFException::throwEx calls a global error handling routine:

  ~~~~~~~~~~~~~{.php}
  onError($message, $file='', $line='')
  ~~~~~~~~~~~~~

- **Non-fatal**: adding a message by calling Controller::appendErrorMsg makes this
  message - together with all accumulated messages before and those to follow -
  available in the next view's @em $errorMsg variable.
  In order to delete old messages the method Controller::setErrorMsg class must
  be called with an empty string parameter.

Many classes define a method @em getErrorMsg, which provides more detailed information
on the cause of an error.

--------------------------------------------------

Concerning the presentation of data, the framework offers developers the following
main points of extension:

- \ref pres_interaction
- \ref pres_layout
- \ref pres_dataformat

## User interaction ## {#pres_interaction_old}

For defining the user interaction in the simplest case solely one configuration file is needed, which
establishes an order of controllers for certain actions. By that a controller for a complex action
can be defined through the combination of primitive controllers (e.g. a MoveItemController from an
InsertItemController and a DeleteItemController).
If new actions should be added, a new controller has to be implemented (for details see \ref howtoapplication).@n
Another way to vary the user interaction is given through the modification of the views, which means the
modification of the form and link definitions in the templates. By defining different contexts it is also
possible to assign different views to a controller while maintaining the same action (e.g. to display an
input form for data in one context and the preview of the same data in another).

## Layout ## {#pres_layout_old}

The application's appearance is completely described by the views. Since these themselves are defined in
corresponding Smarty templates, modifying the templates makes it quite easy to fit the layout to the special
needs of the application.

## Data exchange formats ## {#pres_dataformat_old}

Data sent to the framework and received from the framework is transported in Request and Response instances.
The data is interpreted using an IFormat implementation. This allows to easily implement new data exchange formats.
Already supported formats are HTML (HTMLFormat), JSON (JSONFormat) and SOAP (SOAPFormat).

## Programming the views ## {#pres_views_old}

Views are implemented as HTML pages (defined in the view templates), which typically contain a form,
which displays the data to be modified. For programming dynamic parts and to access
application data the <a href="http://smarty.php.net/" target="_blank">Smarty</a> template
language is used.@n
By default the views are stored as .tpl files in the directory /application/inlcude/views
(see \ref secsmarty). In the directory /wcmf/application/views those views are stored, which
the framework uses for its standard application. These are the basis for the programming of
custom views.@n

In the view templates all data, which was passed to the view instance is accessible (see
\ref howtocontroller). In the simplest case these can be displayed via @em {$variable}. In
addition object data can be accessed by using @em {$object->getValue(...)}. By setting
@em debugView = 1 (see \ref seccms) in the configuration file Smarty will display the data,
which is available in the template, in an external window.@n

The data displayed in the view's form is available to the following controller. Some
(hidden) input fields should always exist. They are defined in the file
/wcmf/application/views/formheader.tpl, which - to simplify matters - should be reused.@n
For handling the form data some JavaScript functions are provided (and documented) in
the file /wcmf/blank/script/common.js.

In the directory /wcmf/lib/presentation/smarty_plugins the framework defines extensions
of the Smarty template language:

- Function @em translate for localization of strings@n
  e.g.: {translate text="Logged in as %1% since %2%" r0="$login" r1="$logindate"}
- Function @em sessionvalue to get a session variable@n
  e.g.: {sessionvalue name="platform"}
- Resource @em lib to integrate templates with a relative path to the framework's
  root directory (/wcmf)@n
  e.g.: {include file="lib:application/views/formheader.tpl"}@n
  ...

## Programming the controllers ## {#pres_controllers_old}

Controllers execute the user-defined actions. In order to implement custom controllers
a class must be derived from the baseclass Controller, which implements the methods
Controller::hasView and Controller::executeKernel.

The Request instance passed to the Controller::initialize method provides all data of the
preceeding view's input fields to the controller. The names of the input fields are the names
of the request values. The controller in turn can pass data to the view by setting them on
the Response instance.

The method Controller::hasView returns @em true or @em false, whether a view is displayed
or not (the return value can differ depending on the context or action, for an example see LoginController).@n
The method Controller::executeKernel executes the actual action. In this method application
data is loaded, modified, created, deleted and where required passed to the view for display
or to the next controller to proceed.
The method either returns @em false, which means, that the ActionMapper should call no further
controller or true. In the latter case the ActionMapper determines the next controller
from the context and action values of the response (see \ref actionkey).
This means if a view should be displayed, the method must return @em false.

While programming custom controllers often the methods Controller::initialize and
Controller::validate are overridden in order to carry out initializations or to
validate provided data.

The framework's controllers are located in the directory /wcmf/application/controller.

## Programming the application ## {#pres_application_old}

A web application typically consists of several input masks (views), which
are used to create, update and delete data. The application is defined by the actions
executable in the individual input masks. Thereby the framework makes no difference
between actions used for data handling and those used to navigate or e.g. initiate the
export of data.

The definition of an action requires the following steps:

-# \ref pres_app1_old
-# \ref pres_app2_old
-# \ref pres_app3_old
-# \ref pres_app4_old
-# \ref pres_app5_old

As an example we use the action for displaying an @em article node in order to
edit it. Let's look at the individual steps:

### Definition of the action name ### {#pres_app1_old}

We name the action @em editArticle. This name need not to be unique in the whole
application. The ActionMapper only requires the name (and the \ref actionkey defined
by the action) to find the next appropriate controller.

### Creating the button to trigger the action ### {#pres_app2_old}

In order to display the data the application must know which article is selected.
This is exactly defined by it's \ref oid. The data transfer between the input
masks is achieved by the HTTP POST mechanism, i.e. a (hidden) input field must exist,
which contains the oid of the article to be displayed. Since for most applications it's often
necessary to transfer an oid, the framework defines a standard field @em oid in each
view (see file /wcmf/application/views/formheader.tpl), which can easily be set
by the JavaScript function @em doDisplay (/wcmf/blank/script/common.js).

The action is triggered upon submission of the input form. Another JavaScript function
(@em submitAction) simplifies the execution. The form data is passed to the main.php
script, which delegates the further execution to the ActionMapper. The link to execute
the action could look like this:

~~~~~~~~~~~~~{.html}
<a href="javascript:setContext('article'); doDisplay('{$article->getOID()}');
  submitAction('editArticle');">{translate text="edit"}</a>
~~~~~~~~~~~~~

For details on programming the views see \ref howtoviews.

### Customizing the configuration file ### {#pres_app3_old}

To determine the controller, which carries out the action, the ActionMapper requires
an appropriate entry in the configuration file (see \ref secactionmapping). If
the controllers name is @em ArticleController, the entry could look like this:

~~~~~~~~~~~~~{.ini}
[actionmapping]
??editArticle = ArticleController
~~~~~~~~~~~~~

Don't forget to introduce the ArticleController in the configuration section \ref secclassmapping.

Additionally the ArticleController should display a view for editing the article. If we
name this view @em article.tpl, the configuration entry would look like the following (see
\ref secviews):

~~~~~~~~~~~~~{.ini}
[views]
ArticleController?? = article.tpl
~~~~~~~~~~~~~

### Implementing the action as a controller ### {#pres_app4_old}

The action is executed in the controller - in this example in the @em ArticleController class.
Since the controller should display a view with the article's data, we first must specify that
the controller has a view and second the data of the article must be passed to the view.@n
At first however it must be assured, that the controller receives an oid. This happens in
the method Controller::validate, which searches for the entry in the passed data:

~~~~~~~~~~~~~{.php}
function validate()
{
  if ($this->_request->getValue('oid') == '')
  {
    $this->setErrorMsg("No 'oid' given in data.");
    return false;
  }
  return true;
}
~~~~~~~~~~~~~

We declare the existence of a view in the method Controller::hasView:

~~~~~~~~~~~~~{.php}
function hasView()
{
  return true;
}
~~~~~~~~~~~~~

Finally the action is executed in the method @em Controller::executeKernel. Here the
controller loads the data and provides it to the view for display by setting it on the
response instance:

~~~~~~~~~~~~~{.php}
function executeKernel()
{
  $persistenceFacade = &PersistenceFacade::getInstance();

  // load model
  $article = &$persistenceFacade->load($this->_request->getValue('oid'), BUILDDEPTH_INFINITE);

  // assign model to view
  $this->_response->setValue('article', $article);

  // stop processing chain
  return false;
}
~~~~~~~~~~~~~

It's important that the method returns false, since this causes the ActionMapper
to end the execution and wait for user input. The display of the view is done by
the framework.

### Displaying data in the view ### {#pres_app5_old}

After the controller has provided the view with the data, the view can display the data.
In our case after the ArticleController has been executed a variable @em article is
known to the view, which matches the article node.@n
The programming of the views is done in HTML together with the Smarty template language.
The file @em article.tpl could contain the following line:

~~~~~~~~~~~~~{.html}
article name: {$nodeUtil->getInputControl($article, "name")}
~~~~~~~~~~~~~

In the curly brackets you can find Smarty code, which calls the method NodeUtil::getInputControl.
This method displays the input control (in our case a textfield), which corresponds to the
article's @em name attribute, in the HTML page. In the same manner the other attributes can be handled.

P E R M I S S I O N S
=====================

Rights can be assigned to the execution of actions in the user interface or to the editing
of domain classes and individual objects (instances of domain classes). For editing content the framework
defines the rights @em read, @em update, @em delete and @em create.@n
The authorization for actions in the user interface is handled by the ActionMapper, for actions
concerning the data the PersistenceMapper checks the permissions (and sets objects, for which
the right @em update is not set, to non-editable (@em is_editable = false) ).
Both classes use the method RightsManager::authorize and generate a fatal error message,
if authorization fails (see \ref howtoerror).
To prevent this the rights can be retrieved directly in order to take appropriate messures:

~~~~~~~~~~~~~{.php}
$rightsManager = &RightsManager::getInstance();
if ($rightsManager->authorize($this->_request->getValue('oid'), '', ACTION_READ))
{
  $object = &$persistenceFacade->load($this->_request->getValue('oid'), BUILDDEPTH_INFINITE);
}
else
{
  // do something else if the user cannot read the object
}
~~~~~~~~~~~~~

In the example the object is only loaded, if it's permitted. For the definition of rights
see \ref secauthorization.
@note If @em anonymous is set to one in the configuration file, the rights management
is disabled (see \ref seccms).

I 1 8 N
=======

For localization of the application the method Message::get is provided. For a given (english)
string this method searches for the required language's version. The language version can
either be passed directly with the method call or can be set application wide (see documentation
of Message::get).@n
How the translation is retrieved depends on the parameter @em usegettext (see \ref seccms).
If it is set to 1, the method uses the PHP function @em gettext. This in turn makes use of
*.mo files in the directory /localeDir/language/LC_MESSAGES - e.g. /locale/de_DE/LC_MESSAGES/main.mo
(see documentation of gettext).@n
If gettext doesn't exist, the language version can also be taken from an associative array named
messages_language (e.g. messages_de_DE).
This must be defined in a file /localeDir/language/LC_MESSAGES/messages_language.php (e.g.
/locale/de_DE/LC_MESSAGES/messages_de_DE.php). The keys of the array are the strings, which are
passed to the method Message::get, the values are the corresponding translations.@n
@note If a translation for a text doesn't exist, the string, which was passed to the method
Message::get, will be used.

For making the localization more comfortable some tools are provided in the directory /wcmf/tools/i18n:
- @em locale.php extracts all strings to be localized (where the method Message::get is used) from the
  application (views, controllers) and creates a *.po file for use with gettext.
- @em po2array.php generates the array definition described above from a *.po file.

For localizing the view templates a Smarty plugin is provided, which is to be used as follows:

~~~~~~~~~~~~~
{translate text="Logged in as %1%" r0=$authUser->getLogin()}
~~~~~~~~~~~~~

The @em parameters of the method Message::get are defined by the values of @em r0, @em r1, ...
