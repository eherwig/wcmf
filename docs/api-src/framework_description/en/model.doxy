/*!
\page model Model
<div class="has-toc"></div>

# Model # {#model_main}

wCMF applications are based on a model. The model defines the key aspects of the
application on a higher abstraction level than code does. You can think of it as
a condensed description of the application.

A template based code generator transforms the model into source code that will
run inside the wCMF framework. Where necessary, the code can then be enhanced
manually inside pre-defined regions. Further generation runs will protect these
manual additions.

We believe that this approach helps to develop a clear concept of the application
and improves code quality and maintainability dramatically.

## Modeling ## {#model_create}

Technically the model is an [UML](http://en.wikipedia.org/wiki/Unified_Modeling_Language)
model that uses the _Chronos_ [profile](http://en.wikipedia.org/wiki/Profile_%28UML%29) from the
[Olympos](http://sourceforge.net/projects/olympos/) project. It is stored in
an XML file (e.g. `model.uml`). This file can be directly edited using
[Eclipse Papyrus](http://www.eclipse.org/papyrus/) or any other compatible UML
modeling tool. Alternatively  you can use the
[Chronos Web Modeler](http://sourceforge.net/projects/olympos/) that allows
browser based collaborative modeling. wCMF uses a minimized version of the code
generator from the Olympos project with wCMF specific templates.

The following diagram shows the workflow of the generator.

\image html generator.png "Generator workflow"

### Chronos profile ### {#model_profile}

_Profiles_ are used to extend UML for different domains. They consist of __stereotypes__
and __tags__ that are applied to model elements in order to express domain specific
features. The following sections describe the stereotypes and tags of the _Chronos_
profile that are used to define various aspects of a wCMF application. The complete
[Chronos profile](https://raw.githubusercontent.com/iherwig/wcmf-default-app/master/model/chronos.profile.uml)
is available on GitHub.

You will notice that only a small part of UML is used to define the application
and not all aspects of the application are defined in the model. Especially the
actual behavior of controllers and domain classes is omitted, since we believe
that this is more efficiently expressed in code. For simplicity and compatibility
reasons all aspects can be modeled in __class diagrams__ using __classes__,
__attributes__ and __associations__.

\note UML elements and concepts that are not mentioned in the following sections
are most likely not supported by the generator and will be ignored.

### Domain classes ### {#model_classes}

The following __stereotypes__ are used to model persistent domain classes and their relations.

| Name | UML meta class | Description | Example
|------|----------------|-------------|--------
| _ChiNode_ | Class | Persistent domain class, must inherit from the \link wcmf::lib::model::Node `Node`\endlink | _Article_
| _ChiValue_ | Attribute | Persistent attribute in a _ChiNode_ | _headline_ of Article
| _ChiValueRef_ | Attribute | ReadOnly-reference to an attribute of another _ChiNode_ | _author_name_ in Article references _name_ in Author
| _ChiManyToMany_ | Class | Connection class in a many to many relation between _ChiNode_ classes, must inherit from \link wcmf::lib::model::Node `Node`\endlink | One _Author_ writes nultiple _Articles_ and one _Article_ has multiple _Authors_
| _ChiAssociation_ | Association | Optional, e.g. used to define a foreign key name in a relation between _ChiNode_ instances | _author_id_ in Article as foreign key to Author table

#### ChiNode / ChiManyToMany #### {#model_chinode}

The following __tags__ are defined on the _ChiNode_ / _ChiManyToMany_ stereotypes.

| Tag | Description | Example | Default value
|-----|-------------|---------|--------------
| _initparams_ | Name of the configuration section, which defines initialization parameters for the \link wcmf::lib::persistence::PersistenceMapper `PersistenceMapper`\endlink instance | _database_ | _database_
| _display_value_ | Attributes to display in a list view: A single attribute name or \|-separated list of attribute names | _name\|date_ | |
| _orderby_ | Definition of default sorting: _none_ (no order), _sortkey_ (generates a _sortkey_ column, that is used for explicit sorting) or the name of any attribute optionally followed by _ASC_ or _DESC_ | _name ASC_ | _none_
| _is_searchable_ | Boolean, indicating whether this type should be included in the default search | _true_ | _true_
| _is_soap_ | Boolean, indicating whether this type should be exposed to the SOAP interface | _true_ | _true_
| _table_name_ | The name of the database table in which instances will be stored | _Author_ | Class name
| _pk_name_ | The name of the primary key column: A single value or \|-separated list of values (the generator will add this automatically, if there is no appropriate attribute) | _fk_user_id\|fk_role_id_ | _id_
| _child_order_ | The order of the associated child types: A single type or \|-separated list of types | _Image\|Textblock\|Attachment_ in Article type | |
| _parent_order_ | The order of the associated parent types: A single type or \|-separated list of types | _Author\|Publisher_ in Article type | |

\note Some of these tags are accessible in the application through the
\link wcmf::lib::persistence::PersistentObject::getProperty `PersistentObject::getProperty`\endlink
method.

#### ChiValue #### {#model_chivalue}

The following __tags__ are defined on the _ChiValue_ stereotype.

| Tag | Description | Example | Default value
|-----|-------------|---------|--------------
| _app_data_type_ | Application specific attribute tags: A single value or \|-separated list of values | _TAG_A\|TAG_B_ | _DATATYPE_ATTRIBUTE_
| _db_data_type_ | The attribute's database type | _TEXT_ | _VARCHAR(255)_ |
| _is_editable_ | Boolean, indicating whether this attribute is editable | _true_ | _true_
| _input_type_ | Name of the attribute's input control as listed in the _InputTypes_ configuration section | _filebrowser_ | _text_
| _display_type_ | Name of the attribute's display type as listed in the _DisplayTypes_ configuration section | _image_ | _text_
| _restrictions_match_ | Name of the attribute's validation type as listed in the _Validator_ configuration section | _regexp:^[0-9]*$_ | |
| _restrictions_not_match_ | _not used_ | | |
| _restrictions_description_ | Validation description used in case of a validation error | _The value must be an integer or empty_ | |
| _column_name_ | The name of the database column in which the attribute will be stored | _name_ | Attribute name

\note Some of these tags are accessible in the application through the
\link wcmf::lib::persistence::PersistentObject::getValueProperty `PersistentObject::getValueProperty`\endlink
method.

#### ChiValueRef #### {#model_chivalueref}

The following __tags__ are defined on the _ChiValueRef_ stereotype.

| Tag | Description | Example | Default value
|-----|-------------|---------|--------------
| _reference_type_ |  Type, that owns the referenced attribute | _Author_ | |
| _reference_value_ | Name of the references attribute | _name_ | |

#### ChiAssociation #### {#model_association}

The following __tags__ are defined on the _ChiAssociation_ stereotype.

| Tag | Description | Example | Default value
|-----|-------------|---------|--------------
| _fk_name_ | Name of the foreign key attribute (the generator will add this automatically, if there is no appropriate attribute) | _author_id_ | _fk_\_type\_ _id_ |

#### Example class diagram #### {#model_class_example}

A simple data model is shown in the diagram below. Each of the domain classes
_Author_, _Article_ and _Image_ is modeled with _ChiNode_ stereotype, their
attributes with _ChiValue_ stereotype. The only exception is the _author_name_ attribute,
which is a reference to the _name_ attribute of _Author_ and therefore uses the
stereotype _ChiValueRef_. As the relations between the classes show, one _Author_
can own several _Articles_ and each _Article_ in turn can contain several _Images_.

All \link wcmf::lib::persistence::PersistenceMapper `PersistenceMapper`\endlink instances
are initialized using the parameters defined in the _database_ configuration section.

In list views _Author_ instances are sorted by _name_ while _Article_ and _Image_
instances get an attribute _sortkey_ which is used to define an explicit order.

\image html model.png "Example class diagram"

#### Associations ####

Relations between domain classes - e.g. parent-child relations - are modeled as
associations. Three different __types of associations__ are supported: _compositions_,
_aggregations_ and _one-directional associations_ as shown in the following
diagram.

\image html associations.png "Association types"

It is important to understand how wCMF recognizes __parents and children__ in an
association. In case of compositions and aggregations the parent is always
the class, that is connected with the diamond end of the association. Other
associations are treated as parent-child relation, if they are only navigable
in one direction, which is then defined as the child to parent direction.

The association types differ in the treatment of children in case of __deletion__
of the parent. In aggregations and normal associations children are not deleted,
while composite children are deleted on parent deletion. On the other hand the
default application allows __creation__ of child instances in a composition, while
the other two types only allow adding existing instances.

The following table summarizes the behavior of the different association types
regarding the operations allowed on child instances:

| Association type | Delete children | Create children | Associate children
|------------------|-----------------|-----------------|-------------------
| Composition      | Yes             | Yes             | No
| Aggregation      | No              | Yes             | Yes
| Association      | No              | No              | Yes

##### Multiplicity #####

The multiplicity at the association ends limits the amount of instances that
are allowed at that relation end. In a typical parent-child relation the parent
end has a value of `1` and the child end has a value of `0..*` meaning that a
child instance is connected to exactly one parent instance, while any number
of child instances may be connected to the parent instance (including zero).
This kind of relation is called __one-to-many relation__ and is easy to realize
in a database by using a _foreign key_ column.

__Many-to-many relations__ on the other hand allow an arbitrary number of
instances at both ends and are typically realized in an database using a
_junction table_. The Chronos profile allows for this by providing the `ChiManyToMany`
stereotype. The following diagram shows how to model a many-to-many relation:

\image html many-to-many.png "Many-to-many relation"

Using compositions ensures that many-to-many instances are deleted correctly,
when the parent instances are deleted.

##### Navigability #####

Another aspect of associations is the use of __arrow ends__ that define the
navigability. If an arrow end is omitted on one end, instances at that end
are not accessible from the other end. Regarding the database schema all three
association types will result in the creation of a foreign key column in the
child table that points to the parent table.

##### Multiple associations #####

Sometimes multiple associations have to be defined between two domain classes.
For example if there are `Person` and `Task` domain classes and tasks should be
associated with persons. If each task should have an owner and a creator, there
will be two aggregations between the two domain classes. In order to allow wCMF
to know which role a person has in relation to a given task, __role names__ have
to be assigned to the association ends.

The following diagram illustrates the given example:

\image html multiple-associations.png "Role names in multiple associations"

#### Inheritance ####

If different domain classes should have the same attributes, a common base class
can make these available to inheriting classes. An example may be an `EntityBase` type,
which defines meta information like creation date and last modification date for
all domain classes. The diagram below illustrates the concept.

\image html inheritance.png "Inheritance"

Inheritance will cause the generator to create new relations in the following cases:

<div class="image-table">
| Parent relations | Child relations
|------------------|----------------
\image html inherited-relation1.png "Subclass B becomes parent of A" | \image html inherited-relation3.png "Subclass B becomes child of A"
\image html inherited-relation2.png "Parent class of B becomes parent of A" | \image html inherited-relation4.png "Child class of B becomes child of A"
</div>

### Application flow ### {#model_flow}

Since a wCMF application is based on the Model-View-Controller pattern, application
flow is defined in terms of _controllers_ and _views_. Controller execution is triggered
by _actions_ which are initiated by the application user.

The following __stereotypes__ are used to model user interaction.

| Name | UML meta class | Description | Example
|------|----------------|-------------|--------
| _ChiController_ | Class | Controller class, must inherit from the \link wcmf::lib::presentation::Controller `Controller`\endlink | _LoginController_
| _ChiView_ | Class | View assigned to a _ChiController_ | _login_
| _ChiActionKey_ | Association | Associates two _ChiController_ instances (to define a control flow) or a _ChiView_ with a _ChiController_ (to define a view attachment), must be _one directional_ | |

\note Multiple action keys may be defined between controllers or controllers and
views each one used in a different context or for a different action.

#### ChiController #### {#model_chicontroller}

No __tags__ are defined on the _ChiController_ stereotype.

#### ChiView #### {#model_chiview}

No __tags__ are defined on the _ChiView_ stereotype.

#### ChiActionKey #### {#model_chiactionkey}

The following __tags__ are defined on the _ChiActionKey_ stereotype.

| Tag | Description | Example | Default value
|-----|-------------|---------|--------------
| _action_ |  The action, which is triggered by this association. If empty, any action is valid | _save_ | |
| _context_ | The context, in which this association is valid. If empty, any context is valid | _author_ | |
| _config_ | The configuration, in which this association is defined | _config.ini_ | _config.ini_ |

#### Example application flow #### {#model_example_flow}

An example for a simple interaction model is given in the diagram below. The
controllers are modeled with the stereotype _ChiController_, the associations with
_ChiActionKey_ stereotype. Each association's tagged values are displayed in an
attached note. Since the association between _AuthorController_ and _author_ view
does not define the tagged values _action_ and _context_, _AuthorController_
displays this view for every action and context. The same applies to _ArticleController_
and the _article_ view. _SaveController_ does not display a view, it only stores
the data passed to it and returns to the next controller.

For associations, which link controllers, at least the tagged value _action_ is set.
Since obviously all _save_ actions result in the execution of _SaveController_,
no context is necessary. The context is helpful, when we want to solve the
ambiguousness of the action _ok_ upon termination of _SaveController_.
We define, that the context is _author_ when editing the author and _article_
when editing articles. By this the application always knows to which controller it
should return to after executing _SaveController_.

\image html flow.png "Example application flow"

\note In order to simplify modeling the following default rule applies:
If a controller has no view attached (meaning that execution of the following
controller needs no user decision) and no _ChiActionKey_ association starts from
that controller, the application automatically chooses the preceding controller
to execute next. For that reason the _ok_ actions may be omitted in the diagram.

### Configuration ### {#model_config}

The following __stereotypes__ are used to model the application configuration.

| Name | UML meta class | Description | Example
|------|----------------|-------------|--------
| _ChiSystem_ | Class | A configuration section, class members and their default values become key-value pairs inside the section | _Database_

#### ChiSystem #### {#model_chisystem}

The following __tags__ are defined on the _ChiSystem_ stereotype.

| Tag | Description | Example | Default value
|-----|-------------|---------|--------------
| _platform_ |  The platform to which the configuration settings apply | _wcmf_ | |
| _config_ | The configuration, in which the settings are defined | _config.ini_ | _config.ini_ |

#### Example configuration #### {#model_example_config}

The following diagram shows the configuration of a database connection. The
connection parameters can be accessed later using the
\link wcmf::lib::config::Configuration::getSection `Configuration::getSection`\endlink
method and passing _database_ as `section` paramter.

\image html config.png "Example configuration"

### Default model ### {#model_default}

The wCMF default application inlcudes a demo UML model located in `model/model.uml`.
It is a good starting point for own experiments. For those who want to start from
scratch there are also base models in _model/base/cwm/_ (for
[Chronos Web Modeler](http://sourceforge.net/projects/olympos/)) and
_model/base/papyrus/_ (for [Eclipse Papyrus](http://www.eclipse.org/papyrus/)).

The default model has the following package structure:

- _model_
  - _wcmf test_
    - _Primitive types_
    - _root_
      - __configuration__ Application specific configuration
        - _default_
          - _config.ini_
            - `«ChiSystem» Config`
            - ...
          - ...
      - _wcmf_ Framework packages with useful (base-)classes
        - _application_
          - _controller_ Existing controllers
            - `«ChiController» AssociateController`
            - ...
        - _lib_
          - _presentation_
            - `«ChiController» Controller` Base class for all controller classes
          - _model_
            - `«ChiNode» Node` Base class for all domain classes
          - _security_
            - _principal_
              - _impl_
                - `AbstractUser` Base class for custom user class
                - `AbstractRole` Base class for custom role class
      - _app_ Application specific packages
        - _src_
          - __model__ Domain class package
            - _wcmf_ Default framework classes
              - `«ChiNode» DBSequence`
              - ...
            - `«ChiNode» EntityBase` Base class for domain classes with audit info
            - ...
          - __controller__ Controller package
            - `«ChiController» RootController` Main controller of default application
          - __views__ Views package
            - `«ChiView» cms` Main view of default application

Application specific model elements will mostly reside in the __emphasized__ packages.

## Generator ## {#model_generator}

<span class="label label-danger">TODO</span>

### Configuration ### {#generator_config}

<span class="label label-danger">TODO</span>

### Running ### {#generator_run}

<span class="label label-danger">TODO</span>

### Artefacts ### {#generator_artefacts}

<span class="label label-danger">TODO</span>
*/
