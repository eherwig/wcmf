/*!
\page architecture Architecture
<div class="has-toc"></div>

\section secarchitecture Architecture

The main architectural concept of wCMF is the well known [Model-View-Controller]
(http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) pattern.
The following sections describe it's implementation in wCMF and introduce some
other key concepts, that are useful to know when using wCMF.

\subsection model Model

An application usually contains a _domain model_ that represents the real-world
concepts of the domain of interest. In object oriented programming this model is
implemented using classes. Depending on the application requirements the instances
of several of these classes have to be persisted in a storage in order to keep the
contained data. The classes that provide the infrastructure for storing data form the
the _persistence layer_.

wCMF defines \link wcmf::lib::persistence::PersistentObject `PersistentObject`\endlink
as base class for persistent domain classes. It mainly implements an unique identifier
for each instance (see \ref oid), tracking of the persistent state, methods for setting
and getting values as well as callback methods for lifecycle events. For the composition
of object graphs the derived class \link wcmf::lib::model::Node `Node`\endlink is used
as base class. It implements relation support for persistent objects.

To retrieve persisted objects \link wcmf::lib::persistence::PersistenceFacade `PersistenceFacade`\endlink
is used. The actual operations for creating, reading, updating and deleting objects
(e.g. SQL commands) are defined in classes implementing the
\link wcmf::lib::persistence::PersistenceMapper `PersistenceMapper`\endlink interface.
Although not necessary there commonly exists one mapper class for each persistent
domain class. Mapper classes are introduced to the persistent facade by configuration.

\image html persistence.png "Persistence layer"

Please refer to the section @ref persistence for a more detailed description of the
persistence layer.

\subsubsection oid Object Identifier

For handling lots of different domain objects an unique identification is crucial. In order to achieve this,
so-called _Object Identifiers_ (_OID_ or _object id_) are used. Various strategies are possible to obtain these
identifiers, e.g. a central registry.

wCMF composes these object ids from the type of the persistent domain class and a number, which is unique
for each type (e.g. _Author::1_). It is important that the object's type can be derived from the object id,
because this enables the \link wcmf::lib::persistence::PersistenceFacade `PersistenceFacade`\endlink to
determine the \link wcmf::lib::persistence::PersistenceMapper `PersistenceMapper`\endlink for the given object
from the configuration. The class \link wcmf::lib::persistence::ObjectId `ObjectId`\endlink implements this
concept.

\subsection controllers_views Presentation

The _presentation layer_ of a wCMF application enables users to interact with the domain model.

Each interaction is initiated by a _request_ and results in a _response_. In a web application the
request data is sent by the user's browser to the server as GET or POST variables.

wCMF's \link wcmf::lib::presentation::Application `Application`\endlink class transforms the request data into
a \link wcmf::lib::presentation::Request `Request`\endlink instance. This instance is then passed to a
\link wcmf::lib::presentation::ActionMapper `ActionMapper`\endlink instance, which creates the
\link wcmf::lib::presentation::Response `Response`\endlink instance and delegates the actual
execution of the request to a \link wcmf::lib::presentation::Controller `Controller`\endlink instance. Different
controllers exist for different actions (e.g. \link wcmf::application::controller::ListController `ListController`\endlink
for listing objects, \link wcmf::application::controller::SearchController `SearchController`\endlink for
searching objects).

The controller is determined by matching specific request parameters against a list of so called
_action keys_ (see @ref actionkey). As the result of it's execution each controller returns action key
parameters in the response data. If these parameters match an existing action key, the associated controller
will be executed by passing the current response as input. In this way complex tasks may be executed by chaining
several controller calls together.

In order to support various data representations, a \link wcmf::lib::presentation::format::Format `Format`\endlink
instance is associated with each request and response. The format is automatically determined by the HTTP
_Content-Type_ resp. _Accept_ headers. \link wcmf::lib::presentation::format::Format `Format`\endlink implementations
are responsible for de-/serializing the request and response data into the desired format (e.g. _JSON_ or _SOAP_).
\link wcmf::lib::presentation::format::impl::HtmlFormat `HtmlFormat`\endlink especially uses a
\link wcmf::lib::presentation::view::View `View`\endlink instance to render the response data into
a HTML page. wCMF's uses [Smarty](http://www.smarty.net/) as the default template engine for HTML output.

\image html presentation.png "Presentation layer"

Please refer to the section @ref persistence for a more detailed description of the
persistence layer.

\subsubsection actionkey Action Key

An important concept of wCMF is that of _Action Keys_. An action key describes the state of the application together
with the action to be performed next. The state, which the application is in, results from the current controller and
the context, in which it is executed. Controllers must exist as classes, whereas contexts and actions may be defined
freely.

The format of the action keys is the following:

@verbatim controller?context?action @endverbatim

In the configuration file an action key has the controller assigned, which should be executed next if
the action key is valid by the application's current state and the user action or the return value of
the current controller (see also @ref applicationflow).@n
Since parts of the action key can be omitted in the definition, an algorithm has to choose,
which action key fits a given value triplet. This algorithm is implemented in the method
WCMFInifileParser::getBestActionKey. In this method the %InifileParser searches in the configuration
file for the a list of combinations successively and ends the search when it found one. After
that the controller, which is assigned to that combination, is executed. The order of the combinations
is the following:

@verbatim
 1. controller?context?action
 2. controller??action
 3. controller?context?
 4. ?context?action
 5. ??action
 6. controller??
 7. ?context?
@endverbatim

As a rule of thumb the action key which describes the state of the application the most
accurate is favoured.@n
Frequent examples are:@n@n

Always execute the %SaveController when action @em save is selected, no matter which state the application is in:
@verbatim ??save = SaveController @endverbatim

Always execute the %ProjektController when the context is @em project as long as no action is specified,
return to the ProjektController respectively from all controllers, which have no specific action assigned
upon termination:
@verbatim ?project? = ProjectController @endverbatim

If no matching action key can be found, the %ActionMapper tries to execute the last %Controller that had a view attached again.
This can save some typing. For example you don't need to configure an action key for the @em ok return action of
SaveController, if you always want to execute the %Controller afterwards, from which the @em save action was initiated.

For details about configuring action keys see @ref configuration.

\subsection accesscontrol Access control

Permissions for controller(|domain class|OID)-context-action triplets (see @ref configuration) are
configured based on roles (defined in the data storage). Several users can be assigned to one role
and each user can be assigned to different roles. The assignment of rights is made in the configuration file.
Here permissions can be explicitly granted or denied. During the application flow authentification/
authorization is accomplished by the RightsManager together with a representation of the current user (as an
instance of the AuthUser class, which is created upon successful login and added to the session data).
*/