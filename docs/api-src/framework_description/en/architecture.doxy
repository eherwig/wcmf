/*!
\page architecture Architecture
<div class="has-toc"></div>

\section secarchitecture Architecture

The main architectural concept of wCMF is the well known [Model-View-Controller]
(http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) pattern.
The following sections describe it's implementation in wCMF and introduce some
other key concepts, that are useful to know when using wCMF.

\subsection model Model

An application usually contains a _domain model_ that represents the real-world
concepts of the domain of interest. In object oriented programming this model is
implemented using classes. Depending on the application requirements the instances
of several of these classes have to be persisted in a storage in order to keep the
contained data. The classes that provide the infrastructure for storing data form the
the _persistence layer_.

wCMF defines \link wcmf::lib::persistence::PersistentObject `PersistentObject`\endlink
as base class for persistent domain classes. It mainly implements an unique identifier
for each instance (see \ref oid), tracking of the persistent state, methods for setting
and getting values as well as callback methods for lifecycle events. For the composition
of object graphs the derived class \link wcmf::lib::model::Node `Node`\endlink is used
as base class. It implements relation support for persistent objects.

To retrieve persisted objects \link wcmf::lib::persistence::PersistenceFacade `PersistenceFacade`\endlink
is used. The actual operations for creating, reading, updating and deleting objects
(e.g. SQL commands) are defined in classes implementing the
\link wcmf::lib::persistence::PersistenceMapper `PersistenceMapper`\endlink interface.
Although not necessary there commonly exists one mapper class for each persistent
domain class. Mapper classes are introduced to the persistent facade by configuration.

\image html persistence.png "Persistence layer"

Please refer to the section @ref persistence for a more detailed description of the
persistence layer.

\subsubsection oid Object Identifier

For handling lots of different domain objects an unique identification is crucial. In order to achieve this,
so-called _Object Identifiers_ (_OID_ or _object id_) are used. Various strategies are possible to obtain these
identifiers, e.g. a central registry.

wCMF composes these object ids from the type of the persistent domain class and a number, which is unique
for each type (e.g. _Author::1_). It is important that the object's type can be derived from the object id,
because this enables the \link wcmf::lib::persistence::PersistenceFacade `PersistenceFacade`\endlink to
determine the \link wcmf::lib::persistence::PersistenceMapper `PersistenceMapper`\endlink for the given object
from the configuration. The class \link wcmf::lib::persistence::ObjectId `ObjectId`\endlink implements this
concept.

\subsection controllers_views Presentation

The _presentation layer_ of a wCMF application enables users to interact with the domain model.

Each interaction is initiated by a _request_ and results in a _response_. In a web application the
request data is sent by the user's browser to the server as GET or POST variables.

wCMF's \link wcmf::lib::presentation::Application `Application`\endlink class transforms the request data into
a \link wcmf::lib::presentation::Request `Request`\endlink instance. This instance is then passed to a
\link wcmf::lib::presentation::ActionMapper `ActionMapper`\endlink instance, which creates the
\link wcmf::lib::presentation::Response `Response`\endlink instance and delegates the actual
execution of the request to a \link wcmf::lib::presentation::Controller `Controller`\endlink instance. Different
controllers exist for different actions (e.g. \link wcmf::application::controller::ListController `ListController`\endlink
for listing objects, \link wcmf::application::controller::SearchController `SearchController`\endlink for
searching objects).

The controller is determined by matching specific request parameters against a list of so called
_action keys_ (see @ref actionkey). As the result of it's execution each controller returns action key
parameters in the response data. If these parameters match an existing action key, the associated controller
will be executed by passing the current response as input. In this way complex tasks may be executed by chaining
several controller calls together.

It's important to notice that a \link wcmf::lib::presentation::format::Format `Format`\endlink instance is
associated with each request and response. The format is determined by the HTTP _Content-Type_ resp. _Accept_
headers. \link wcmf::lib::presentation::format::Format `Format`\endlink implementations are responsible for
de-/serializing the request and response data into the desired format (e.g. _JSON_ or _SOAP_).
\link wcmf::lib::presentation::format::impl::HtmlFormat `HtmlFormat`\endlink especially uses a
\link wcmf::lib::presentation::view::View `View`\endlink instance to render the response data into
a HTML page. wCMF's uses [Smarty](http://www.smarty.net/) as the default template engine for HTML output.

\image html presentation.png "Presentation layer"

Please refer to the section @ref persistence for a more detailed description of the
persistence layer.

\subsubsection actionkey Action Key

For details about configuring action keys see @ref configuration.

\subsection accesscontrol Access control

Permissions for controller(|domain class|OID)-context-action triplets (see @ref configuration) are
configured based on roles (defined in the data storage). Several users can be assigned to one role
and each user can be assigned to different roles. The assignment of rights is made in the configuration file.
Here permissions can be explicitly granted or denied. During the application flow authentification/
authorization is accomplished by the RightsManager together with a representation of the current user (as an
instance of the AuthUser class, which is created upon successful login and added to the session data).
*/