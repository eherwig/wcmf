/*!
\page persistence Persistence
<div class="has-toc"></div>

# Persistence # {#pers_main}

Persistence refers to that part of the domain model, which we could call the data model.

## Data model ## {#pers_datamodel}

The data model consists of domain classes whose instances are saved in the storage.
The following steps need to be accomplished in order to make domain class instances
persistent.

- Definition and creation of the database tables, if using a database storage.
- Implementation of the \link wcmf::lib::persistence::PersistenceMapper `PersistenceMapper`\endlink
  classes, which map the domain classes to these tables, or anything else that is used as storage.
- Implementation of the domain classes as subclasses of \link wcmf::lib::model::Node `Node`\endlink.
- Configuration of the persistence layer.

@note If you are using the generator to create the application from a model
(see \ref model), all necessary code will be generated automatically.

### Database tables ### {#pers_tables}

Still the most common storage for web applications is a _SQL_ database (e.g.
[MySQL](http://www.mysql.com/)). It is also wCMF's default storage. Although not
strictly necessary it is recommended to use one database table for each persistent
class, where each class property maps to one table column and each row stores one
instance. The object identity is stored in the primary key column, which is named
_id_ by default.

@note wCMF uses a table called `DBSequence` for retrieving the next id value used for
insertion, since _autoincrement_ columns are not supported on all database servers.

#### Relations #### {#pers_relations}

The following two relations types must be considered, when modeling the data
tables:

- **One-To-Many** relations are realized by adding a foreign key column to the
child table (_many_-side), which points to the parent table (_one_-side). This
column is named _fk_ _ + parent table name  + _ _id_ by default (e.g. _fk_author_id_).

- **Many-To-Many** relations between two domain classes, are established by defining
a connection table. This table contains two primary keys, which point to the two
connected tables.

### Persistence Mappers ### {#pers_mappers}

wCMF uses persistence mapper classes to communicate between the application and
the persistent storage (see \ref arch_main). These classes implement the
\link wcmf::lib::persistence::PersistenceMapper `PersistenceMapper`\endlink interface,
which defines methods for all persistence actions. By using this pattern wCMF
does not make any assumptions about the actual storage, which can be flat files,
a database or anything else a mapper is able to handle. This approach also makes
it easy to connect an existing storage to a newly created wCMF application.

In order to simplify the implementation of mapper classes, wCMF already contains
a class hierarchy for a common mapping approach, which maps each concrete class
to one database table ([Concrete Table Inheritance]
(http://martinfowler.com/eaaCatalog/concreteTableInheritance.html)). In this
hierarchy \link wcmf::lib::model::mapper::RDBMapper `RDBMapper`\endlink handles
the communication with the relational database, while
\link wcmf::lib::model::mapper::NodeUnifiedRDBMapper `NodeUnifiedRDBMapper`\endlink
defines the actual mapping rules. Application developers simply need to implement
one subclass of \link wcmf::lib::model::mapper::NodeUnifiedRDBMapper `NodeUnifiedRDBMapper`\endlink
for each persistent domain class, which declares the mapping of the attributes and
relations of that class.

@note All mapper classes, that are created by the generator are
\link wcmf::lib::model::mapper::NodeUnifiedRDBMapper `NodeUnifiedRDBMapper`\endlink
subclasses.

### Domain Classes ### {#pers_classes}

Domain class instances hold the data that are used in the application and persisted
in the storage.

Persistent domain classes either inherit from
- \link wcmf::lib::persistence::PersistentObject `PersistentObject`\endlink, which
is a container with value getter and setter methods, or from
- \link wcmf::lib::model::Node `Node`\endlink, which adds methods for managing
relations.

These two classes are completely generic, the actual identity of the domain class -
that is the _properties_ and the _relations_ - are defined by the related
\link wcmf::lib::persistence::PersistenceMapper `PersistenceMapper`\endlink.

So if no additional domain logic is required in the domain class, it would be
sufficient to use \link wcmf::lib::model::Node `Node`\endlink as domain class.
But in many cases you will want to execute custom code for \ref pers_hooks or
\ref pers_validation and therefor create a custom subclass of
\link wcmf::lib::model::Node `Node`\endlink.

@note All domain classes, that are created by the generator are
\link wcmf::lib::model::Node `Node`\endlink subclasses.

#### Persistence Hooks #### {#pers_hooks}

Persistence hooks are methods that are called at certain points of the lifecycle of
an instance. The default implementation of these methods is empty - in fact their
sole purpose is to be overwritten in subclasses on order to implement special
functionality that should be executed at those points.
\link wcmf::lib::persistence::PersistentObject `PersistentObject`\endlink defines
the following persistence hooks:

- `afterCreate`
- `beforeInsert`
- `afterInsert`
- `afterLoad`
- `beforeUpdate`
- `afterUpdate`
- `beforeDelete`
- `afterDelete`

#### Values, Properties and Tags #### {#pers_values}

<span class="label label-danger">TODO</span>

### Configuration ### {#pers_config}

The configuration tells the application which mapper classes are responsible
for which domain classes. This assignment is defined in the `TypeMapping`
configuration section. The following example shows the appropriate entries
for the `Author` domain class:

~~~~~~~~~~~~~{.ini}
[TypeMapping]
app.src.model.Author = $app_src_model_AuthorRDBMapper

[app_src_model_AuthorRDBMapper]
__class = app\src\model\AuthorRDBMapper
connectionParams = $database

[Database]
dbType = sqlite
dbHostName = 127.0.0.1
dbName = app/test-db.sq3
dbUserName =
dbPassword =
dbCharSet = utf8
~~~~~~~~~~~~~

See \ref configuration for details about the configuration format.

## Usage ## {#pers_node}

The following sections show some basic examples for using the persistence layer.

### Loading objects ### {#pers_load}

~~~~~~~~~~~~~{.php}
$oid = new ObjectId('Author', 1);

// load the Author instance with id 1
$author = ObjectFactory::getInstance('persistenceFacade')->load($oid);

// PersistenceFacade will return null, if an instance does not exist
if ($author == null) {
  echo("An Author with object id ".$oid." does not exist.";
}
~~~~~~~~~~~~~

In the example the _Author_ instance with id _1_ is loaded.

#### Build depth #### {#pers_builddepth}

When loading objects we generally distinguish between **eager** and **lazy** loading
(see [Lazy loading](http://en.wikipedia.org/wiki/Lazy_loading)).
By default \link wcmf::lib::persistence::PersistenceFacade `PersistenceFacade`\endlink
performs _lazy loading_ by using _virtual proxies_ (instances of
\link wcmf::lib::persistence::PersistentObjectProxy `PersistentObjectProxy`\endlink).
That means that related objects are retrieved from the store, only when they are
actually accessed. In order to perform _eager loading_, a
\link wcmf::lib::persistence::BuildDepth `BuildDepth`\endlink
value may be passed in the method calls:

~~~~~~~~~~~~~{.php}
$oid = new ObjectId('Author', 1);

// load the Author instance with id 1 together with all related objects
$author = ObjectFactory::getInstance('persistenceFacade')->load($oid, BuildDepth::INFINITE);
~~~~~~~~~~~~~

In this example the _Author_ instance with id _1_ is loaded together with all related
objects recursively.

Instead of a \link wcmf::lib::persistence::BuildDepth `BuildDepth`\endlink
value, an integer number may be passed indicating the depth of relations to load.
The following image illustrates the _build depth_ parameter for a simple model.

\image html builddepth.png "Build depth"

If using a build depth value of _1_ the _Author A_ instance will be loaded together
with it's related _Book_ instances (_Book A_, _Book B_). A value of _2_ will also load
the _Chapter_ instances (_Chapter A1_, _Chapter A2_). The default value is
\link wcmf::lib::persistence::BuildDepth::SINGLE `BuildDepth::SINGLE`\endlink,
which means that only the _Author A_ instance is loaded. In the above illustration
the value of _2_ is equal to passing
\link wcmf::lib::persistence::BuildDepth::INFINITE `BuildDepth::INFINITE`\endlink.

### Searching objects ### {#pers_search}

To search objects in the store the
\link wcmf::lib::persistence::PersistenceFacade::loadObjects `PersistenceFacade::loadObjects`\endlink
method may be used. It allows to set the conditions that loaded objects should match.

~~~~~~~~~~~~~{.php}
$criteria = array(
  new Criteria("Book", "title", "LIKE", "A%"),
  new Criteria("Book", "year", ">=", "2014")))
)

// load all Book instances with titles starting with A and release date 2014 or later
$books = ObjectFactory::getInstance('persistenceFacade')->loadObjects("Book", BuildDepth::SINGLE, $criteria);
~~~~~~~~~~~~~

In this example all _Book_ instances with titles starting with _A_ and release date
_2014 or later_ are loaded.

For more complex cases the class \link wcmf::lib::model::ObjectQuery `ObjectQuery`\endlink
may be used for searching.

<span class="label label-danger">TODO</span>

#### Sorting #### {#pers_sorting}

<span class="label label-danger">TODO</span>

#### Pagination #### {#pers_pagination}

<span class="label label-danger">TODO</span>

### Traversing object graphs ### {#pers_iter}

<span class="label label-danger">TODO</span>

### Modifying objects ### {#pers_modify}

<span class="label label-danger">TODO</span>

## Validation ## {#pers_validation}

<span class="label label-danger">TODO</span>

## Concurrency ## {#pers_concurrency}

<span class="label label-danger">TODO</span>

## Transactions ## {#pers_tx}

<span class="label label-danger">TODO</span>
*/