/*!
\page persistence Persistence
<div class="has-toc"></div>

\section secpersistence Persistence

\subsection howtotype Definition of the data model

The data model defines the domain classes. In principle the following steps are necessary
to to make the domain classes available in the application:

-# Definition and creation of the database tables.@n
-# Implementation of the PersistenceMapper classes, which map the domain classes to the tables.@n
-# Creation of special domain classes, if the Node class is not sufficient.@n

Basically it doesn't matter, in which format the application data is stored. To load and store
data application developers solely have to communicate with the PersistenceFacade.
The PersistenceMapper classes have the actual knowledge of how to access the data.
This abstraction makes it for instance possible to easily migrate the data storage from file based
to databased. Only the mappers have to be exchanged. On the other hand it's also possible - an
adequate implementation of the mappers assumed - to access arbitrary database schemes, which
eases the connection of the wCMF to existing data sources.

In practice it has been proved as advantageous to use a database as storage medium, because it has
a better performance and can handle bigger amounts of data much better than XML files can.@n
It is recommended to define one table for each domain class in the database scheme (e.g. @em author, @em article).
On one hand it makes the import and export from and to other applications easier and on the other
hand the access to the data is optimized compared to storing all data in one table, because then
additional joins would be required to determine data types and other meta information. In addition the
table columns can be more easily adjusted to the needs of the domain classes (in an extreme case all data
must be stored as BLOB in an universal data table). NodeToSingleTableMapper implements the storage of all
data in one table, which - for the said reasons - isn't recommended.

Proceeding on these assumptions the creation of the data model becomes a lot simpler.

\subsubsection howtotables Definition of the database tables

We start with step 1. Assuming we're in the fortunate situation of defining the database tables
ourselves. Then we proceed as follows.

- For each domain class we create one table.
- For each attribute of a domain class we define a row with the appropriate datatype.

Further attributes follow a scheme, which is predefined by the NodeUnifiedRDBMapper. This
makes the creation of the mappers easier:

- Each table gets a primary key named @em id (int(11))
- If one table depends on another, it gets a foreign key @em fk_table_id (int(11)), where
  @em table stands for the name of the parent table.

If an N to M relation should be established between two domain classes (tables), a connection
table must be defined. This table contains two primary keys, which point to the two connected
tables.

As an example serves a domain class @em Article, which is related to an @em Author:
@verbatim
 CREATE TABLE `Article ` (
 `id` int(11) NOT NULL default '0',
 `fk_author_id` int(11) default NULL,
 `headline` VARCHAR(255),
 `text` TEXT,
 `sortkey` INT(3),
 PRIMARY KEY (`id`)
 ) TYPE=MyISAM;
@endverbatim

If the database tables already exist, this step is skipped. This however means, that more work
must be put into the implementation of the PersistenceMapper.

\subsubsection howtomapper Implementation of the PersistenceMapper

Of course it's always possible to write own mappers. These must inherit from PersistenceMapper
and implement the abstract methods given there.
Since the framework already provides mappers, it's easier to use these as base classes. In case of a relational
database it's possible to derive custom mappers from NodeRDBMapper. Then the methods for defining
the SQL statements must be implemented.

Assuming the database tables are created by the scheme above, we can proceed to the next step
and use NodeUnifiedRDBMapper as baseclass for our mappers. After that we have to implement the
methods RDBMapper::getType, NodeRDBMapper::createObject, NodeUnifiedRDBMapper::getTableName,
PersistenceMapper::getPkNames, NodeUnifiedRDBMapper::getMyFKColumnNameImpl and
NodeUnifiedRDBMapper::getObjectDefinitionImpl. These methods merely ask for properties of
the domain class.

The method NodeUnifiedRDBMapper::getObjectDefinitionImpl is the most important method. It supplies an
associative array, in which the attributes of the domain class (@em _datadef) the parent and the child
domain classes (@em _children) are defined. In addition the Article contains a reference to
the name of the Author (@em _ref), which allows to access the Author without loading it.@n
Detailed information on the implemetation can be found under NodeUnifiedRDBMapper::getObjectDefinitionImpl.

For configuring the domain classes in the configuration file see @ref sectypemapping.

\subsubsection howtodomainclass Creating the domain classes

The framework's PersistenceMapper work with the class Node, a subclass of PersistentObject.
Different domain classes are created by specifying the type attribute (Node::getType) and
a set of attributes (Node::getValueNames).
So the class Node is a generic data container, into which data can be put by the method
Node::setValue and retrieved by the method Node::getValue. For most applications this will
do.

If however more specialized domain classes are required for the application, they must
be created by the PersistenceMapper. In this case subclasses of NodeRDBMapper must
override the method NodeRDBMapper::createObject, which in turn creates instances of the
special domain class.

\subsection howtonode Working with the class Node

\subsubsection howtoload Loading a data structure

@code
   $persistenceFacade = &PersistenceFacade::getInstance();

   // load model
   $oid = PersistenceFacade::composeOID(array('type' => 'section', 'id' => array('1')));
   $node = &$persistenceFacade->load($oid, BUILDDEPTH_INFINITE);
   if ($node == null)
     Message::error("A Node with object id ".$oid." does not exist.";
@endcode

The example loads the section node with id 1 and all children nodes. If the oid of the
requested node is not known either use the appropriate methods of PersistenceFacade
(e.g. PersistenceFacade::getOID) or in more complex cases do an ObjectQuery.

\subsubsection howtoiter Traversing a data structure

@code
   $iterator = new NodeIterator($node);
   while(!($iterator->isEnd()))
   {
     $currentObject = &$iterator->getCurrentObject();
     Message::trace($currentObject->getOID());
     $iterator->proceed();
   }
@endcode

The example outputs the object ids of all nodes that are descendents of $node.

\subsubsection howtooutput Output a data structure into different formats

@code
   $iterator = new NodeIterator($node);

   // Output into dot format
   $filename = "graph.dot";
   $dotOS = new DotOutputStrategy($filename);
   $ov = new OutputVisitor($dotOS);
   $ov->startIterator($iterator);

   iterator->reset($node);

   // Output into XML format
   $filename = "graph.xml";
   $xmlOS = new XMLOutputStrategy($filename);
   $ov->setOutputStrategy($xmlOS);
   $ov->startIterator($iterator);
@endcode

\subsubsection howtomodify Modifying a data structure

@code
   $node->setValue('text', 'hello world!', DATATYPE_ATTRIBUTE);

   // Saving changes
   // If one node has been modified
   $node->save();

   // If several connected nodes have been modified
   $iterator = new NodeIterator($node);
   $cv = new CommitVisitor();
   $cv->startIterator($iterator);
@endcode

\subsection howtoconcurrency Concurrency

If more than one user works with the application at the same time, conflicts can occur, if two
users want to edit the same object concurrently. In this case the first user can request
a lock on that object, which only allows reading access to succeeding users. This lock will
be transfered to all instances loaded in the future as long until the user unlocks the object,
which happens automatically upon execution of an action (call to main.php).
In the sourcecode this looks as follows:
@verbatim
 $lockManager = &LockManager::getInstance();
 $object = &$persistenceFacade->load($this->_request->getValue('oid'), BUILDDEPTH_INFINITE);

 // if the object is locked by another user we retrieve the lock to show a message
 $lock = $object->getLock();
 if ($lock != null)
 {
   $lockMsg .= $lockManager->getLockMessage($lock, $recipe->getName());
 }
 else
 {
   // try to lock object
   $lockManager->aquireLock($this->_request->getValue('oid'));
 }
@endverbatim

The functionality described above is imlemented in the method LockManager::handleLocking,
with the only difference that this method only acquires a lock in cases in which the
user is allowed to update the object.@n
An object, which is loaded by another user is set to non-editable (@em is_editable = false)
automatically upon loading.

\subsection howtotransactions Transactions
*/