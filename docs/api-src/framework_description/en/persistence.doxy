/*!
\page persistence Persistence
<div class="has-toc"></div>

# Persistence # {#pers_main}

Persistence is related to that part of the domain model, which we could call
the data model.

## Definition of the data model ## {#pers_datamodel}

The data model consists of domain classes whose instances are persisted in the storage.
The following steps need to be accomplished in order to make domain class instances
persistent.

- Definition and creation of the database tables, if using a database storage.
- Implementation of the \link wcmf::lib::persistence::PersistenceMapper `PersistenceMapper`\endlink
  classes, which map the domain classes to these tables, or anything else that is used as storage.
- Implementation of the domain classes as subclasses of \link wcmf::lib::model::Node `Node`\endlink.
- Configuration of the persistence layer.

@note If you are using the generator to create the application from a model
(see \ref modeling), all necessary code will be generated automatically.

### Database tables ### {#pers_tables}

Still the most common storage for web applications is a _SQL_ database (e.g.
[MySQL](http://www.mysql.com/)). It is also wCMF's default storage. Although not
strictly necessary it is recommended to use one database table for each persistent
class, where each class property maps to one table column and each row stores one
instance. The object identity is stored in the primary key column, which is named
_id_ by default.

@note wCMF uses a table called `DBSequence` for retrieving the next id value used for
insertion, since _autoincrement_ columns are not supported on all database servers.

#### Relations #### {#pers_relations}

The following two relations types must be considered, when modeling the data
tables:

- **One-To-Many** relations are realized by adding a foreign key column to the
child table (_many_-side), which points to the parent table (_one_-side). This
column is named _fk_ _ + parent table name  + _ _id_ by default (e.g. _fk_author_id_).

- **Many-To-Many** relations between two domain classes, are established by defining
a connection table. This table contains two primary keys, which point to the two
connected tables.

### Persistence Mappers ### {#pers_mappers}

wCMF uses persistence mapper classes to communicate between the application and
the persistent storage (see \ref arch_main). These classes implement the
\link wcmf::lib::persistence::PersistenceMapper `PersistenceMapper`\endlink interface,
which defines methods for all persistence actions. By using this pattern wCMF
does not make any assumptions about the actual storage, which can be flat files,
a database or anything else a mapper is able to handle. This approach also makes
it easy to connect an existing storage to a newly created wCMF application.

In order to simplify the implementation of mapper classes, wCMF already contains
a class hierarchy for a common mapping approach, which maps each concrete class
to one database table ([Concrete Table Inheritance]
(http://martinfowler.com/eaaCatalog/concreteTableInheritance.html)). In this
hierarchy \link wcmf::lib::model::mapper::RDBMapper `RDBMapper`\endlink handles
the communication with the relational database, while
\link wcmf::lib::model::mapper::NodeUnifiedRDBMapper `NodeUnifiedRDBMapper`\endlink
defines the actual mapping rules. Application developers simply need to implement
one subclass of \link wcmf::lib::model::mapper::NodeUnifiedRDBMapper `NodeUnifiedRDBMapper`\endlink
for each persistent domain class, which declares the mapping of the attributes and
relations of that class.

@note All mapper classes, that are created by the generator are
\link wcmf::lib::model::mapper::NodeUnifiedRDBMapper `NodeUnifiedRDBMapper`\endlink
subclasses.

### Domain Classes ### {#pers_classes}

Domain class instances hold the data that are used in the application and persisted
in the storage.

Persistent domain classes either inherit from
- \link wcmf::lib::persistence::PersistentObject `PersistentObject`\endlink, which
is a container with value getter and setter methods, or from
- \link wcmf::lib::model::Node `Node`\endlink, which adds methods for managing
relations.

These two classes are completely generic, the actual identity of the domain class -
that is the _properties_ and the _relations_ - are defined by the related
\link wcmf::lib::persistence::PersistenceMapper `PersistenceMapper`\endlink.

So if no additional domain logic is required in the domain class, it would be
sufficient to use \link wcmf::lib::model::Node `Node`\endlink as domain class.
But in many cases you will want to execute custom code for persistent hooks or
validation and therefor create a custom subclass of
\link wcmf::lib::model::Node `Node`\endlink.

@note All domain classes, that are created by the generator are
\link wcmf::lib::model::Node `Node`\endlink subclasses.

### Configuration ### {#pers_config}

The configuration tells the application which mapper classes are responsible
for which domain classes. This assignment is defined in the `TypeMapping`
configuration section. The following example shows the appropriate entries
for the `Author` domain class:

~~~~~~~~~~~~~{.ini}
[TypeMapping]
app.src.model.Author = $app_src_model_AuthorRDBMapper

[app_src_model_AuthorRDBMapper]
__class = app\src\model\AuthorRDBMapper
connectionParams = $database

[Database]
dbType = sqlite
dbHostName = 127.0.0.1
dbName = app/test-db.sq3
dbUserName =
dbPassword =
dbCharSet = utf8
~~~~~~~~~~~~~

See \ref configuration for details about the configuration format.

----------------------------------------------------------------------

## Using the class Node ## {#pers_node}

### Loading objects ### {#pers_load}

~~~~~~~~~~~~~{.php}
$persistenceFacade = &PersistenceFacade::getInstance();

// load model
$oid = PersistenceFacade::composeOID(array('type' => 'section', 'id' => array('1')));
$node = &$persistenceFacade->load($oid, BUILDDEPTH_INFINITE);
if ($node == null)
  Message::error("A Node with object id ".$oid." does not exist.";
~~~~~~~~~~~~~

The example loads the section node with id 1 and all children nodes. If the oid of the
requested node is not known either use the appropriate methods of PersistenceFacade
(e.g. PersistenceFacade::getOID) or in more complex cases do an ObjectQuery.

### Searching objects ### {#pers_search}

### Traversing objects ### {#pers_iter}

~~~~~~~~~~~~~{.php}
$iterator = new NodeIterator($node);
while(!($iterator->isEnd()))
{
  $currentObject = &$iterator->getCurrentObject();
  Message::trace($currentObject->getOID());
  $iterator->proceed();
}
~~~~~~~~~~~~~

The example outputs the object ids of all nodes that are descendents of $node.

### Output objects ### {#pers_output}

~~~~~~~~~~~~~{.php}
$iterator = new NodeIterator($node);

// Output into dot format
$filename = "graph.dot";
$dotOS = new DotOutputStrategy($filename);
$ov = new OutputVisitor($dotOS);
$ov->startIterator($iterator);

iterator->reset($node);

// Output into XML format
$filename = "graph.xml";
$xmlOS = new XMLOutputStrategy($filename);
$ov->setOutputStrategy($xmlOS);
$ov->startIterator($iterator);
~~~~~~~~~~~~~

### Modifying objects ### {#pers_modify}

~~~~~~~~~~~~~{.php}
// Create

$node->setValue('text', 'hello world!', DATATYPE_ATTRIBUTE);

// Saving changes
// If one node has been modified
$node->save();

// If several connected nodes have been modified
$iterator = new NodeIterator($node);
$cv = new CommitVisitor();
$cv->startIterator($iterator);

// Delete
~~~~~~~~~~~~~

## Concurrency ## {#pers_concurrency}

If more than one user works with the application at the same time, conflicts can occur, if two
users want to edit the same object concurrently. In this case the first user can request
a lock on that object, which only allows reading access to succeeding users. This lock will
be transfered to all instances loaded in the future as long until the user unlocks the object,
which happens automatically upon execution of an action (call to main.php).
In the sourcecode this looks as follows:

~~~~~~~~~~~~~{.php}
$lockManager = &LockManager::getInstance();
$object = &$persistenceFacade->load($this->_request->getValue('oid'), BUILDDEPTH_INFINITE);

// if the object is locked by another user we retrieve the lock to show a message
$lock = $object->getLock();
if ($lock != null)
{
  $lockMsg .= $lockManager->getLockMessage($lock, $recipe->getName());
}
else
{
  // try to lock object
  $lockManager->aquireLock($this->_request->getValue('oid'));
}
~~~~~~~~~~~~~

The functionality described above is imlemented in the method LockManager::handleLocking,
with the only difference that this method only acquires a lock in cases in which the
user is allowed to update the object.@n
An object, which is loaded by another user is set to non-editable (@em is_editable = false)
automatically upon loading.

## Transactions ## {#pers_tx}
*/