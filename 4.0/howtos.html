<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>wCMF 4.0: HowTos</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
          <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    <link href="theme/css/doxstyles.css" rel="stylesheet">
    <script src="theme/js/jquery/jquery-2.1.1.min.js"></script>
    <script src="theme/js/jquery/jquery-ui-1.11.1.custom.min.js"></script>
    <script src="theme/bootstrap3/js/bootstrap.min.js"></script>
    <link href="theme/bootstrap3/css/bootstrap.min.css" rel="stylesheet">
    <link href="theme/bootstrap3/css/font-awesome.min.css" rel="stylesheet">
    <script src="theme/js/tocify/jquery.tocify.min.js"></script>
    <link href="theme/js/tocify/jquery.tocify.css" rel="stylesheet">
    <script src="theme/js/doxy-boot.js"></script>
    <script src="theme/js/application.js"></script>
    <script src="dynsections.js"></script>
    <link href="theme/css/syntax.css" rel="stylesheet">
    <link href="theme/css/style.css" rel="stylesheet">
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="wCMF"/>
  </head>
  <body style="min-height: 200px; padding-top: 50px;">
    <header class="navbar navbar-inverse navbar-fixed-top bs-docs-nav" role="banner">
      <div class="container">
        <div class="row">
          <div class="col-md-offset-1 col-sm-offset-0 col-md-10">
            <div class="navbar-header">
              <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".menu-navbar-collapse">
                <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="index.html">wCMF 4.0</a>
            </div>
            <div class="collapse navbar-collapse menu-navbar-collapse" role="navigation">
              <ul class="nav navbar-nav">
                <li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown"><i class="fa fa-hand-o-right"></i> Guides <b class="caret"></b></a>
                  <ul class="dropdown-menu">
                    <li><a href="gettingstarted.html">Getting started</a></li>
                    <li><a href="architecture.html">Architecture</a></li>
                    <li><a href="#">Modeling</a></li>
                    <li><a href="howtos.html">Persistence</a></li>
                    <li><a href="#">Controllers</a></li>
                    <li><a href="configuration.html">Configuration</a></li>
                    <li><a href="extensionpoints.html">Permissions</a></li>
                    <li><a href="#">I18N</a></li>
                  </ul>
                </li>
                <li class="dropdown"><a href="annotated.html"><i class="fa fa-file-text-o"></i> API</a></li>
                <li><a href="https://github.com/iherwig/wcmf" target="_blank"><i class="fa fa-github"></i> Code</a></li>
              </ul>
              <ul class="nav navbar-nav pull-right">
                <form class="navbar-form navbar-left" role="search" method="get" action="search.php">
                  <div class="form-group">
                    <input type="text" class="form-control" placeholder="Search" name="query">
                  </div>
                  <button type="submit" class="btn btn-default">Submit</button>
                </form>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </header>
    <a class="anchor" id="top"></a>
    <div class="content" id="content">
      <div class="container">
        <div class="row" style="margin-top: 20px;">
          <div class="col-md-offset-1 col-sm-offset-0 col-md-10 panel panel-default">
            <div>
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">HowTos </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="has-toc"></div><h1><a class="anchor" id="sechowtos"></a>
HowTos</h1>
<h2><a class="anchor" id="howtotype"></a>
Definition of the data model</h2>
<p>The data model defines the domain classes. In principle the following steps are necessary to to make the domain classes available in the application:</p>
<ol type="1">
<li>Definition and creation of the database tables.<br />
</li>
<li>Implementation of the PersistenceMapper classes, which map the domain classes to the tables.<br />
</li>
<li>Creation of special domain classes, if the Node class is not sufficient.<br />
 Basically it doesn't matter, in which format the application data is stored. To load and store data application developers solely have to communicate with the PersistenceFacade. The PersistenceMapper classes have the actual knowledge of how to access the data. This abstraction makes it for instance possible to easily migrate the data storage from file based to databased. Only the mappers have to be exchanged. On the other hand it's also possible - an adequate implementation of the mappers assumed - to access arbitrary database schemes, which eases the connection of the wCMF to existing data sources.</li>
</ol>
<p>In practice it has been proved as advantageous to use a database as storage medium, because it has a better performance and can handle bigger amounts of data much better than XML files can.<br />
It is recommended to define one table for each domain class in the database scheme (e.g. <em>author</em>, <em>article</em>). On one hand it makes the import and export from and to other applications easier and on the other hand the access to the data is optimized compared to storing all data in one table, because then additional joins would be required to determine data types and other meta information. In addition the table columns can be more easily adjusted to the needs of the domain classes (in an extreme case all data must be stored as BLOB in an universal data table). NodeToSingleTableMapper implements the storage of all data in one table, which - for the said reasons - isn't recommended.</p>
<p>Proceeding on these assumptions the creation of the data model becomes a lot simpler.</p>
<h3><a class="anchor" id="howtotables"></a>
Definition of the database tables</h3>
<p>We start with step 1. Assuming we're in the fortunate situation of defining the database tables ourselves. Then we proceed as follows.</p>
<ul>
<li>For each domain class we create one table.</li>
<li>For each attribute of a domain class we define a row with the appropriate datatype.</li>
</ul>
<p>Further attributes follow a scheme, which is predefined by the NodeUnifiedRDBMapper. This makes the creation of the mappers easier:</p>
<ul>
<li>Each table gets a primary key named <em>id</em> (int(11))</li>
<li>If one table depends on another, it gets a foreign key <em>fk_table_id</em> (int(11)), where <em>table</em> stands for the name of the parent table.</li>
</ul>
<p>If an N to M relation should be established between two domain classes (tables), a connection table must be defined. This table contains two primary keys, which point to the two connected tables.</p>
<p>As an example serves a domain class <em>Article</em>, which is related to an <em>Author:</em> </p><pre class="fragment"> CREATE TABLE `Article ` (
 `id` int(11) NOT NULL default '0',
 `fk_author_id` int(11) default NULL,
 `headline` VARCHAR(255),
 `text` TEXT,
 `sortkey` INT(3),
 PRIMARY KEY (`id`)
 ) TYPE=MyISAM;
</pre><p>If the database tables already exist, this step is skipped. This however means, that more work must be put into the implementation of the PersistenceMapper.</p>
<h3><a class="anchor" id="howtomapper"></a>
Implementation of the PersistenceMapper</h3>
<p>Of course it's always possible to write own mappers. These must inherit from PersistenceMapper and implement the abstract methods given there. Since the framework already provides mappers, it's easier to use these as base classes. In case of a relational database it's possible to derive custom mappers from NodeRDBMapper. Then the methods for defining the SQL statements must be implemented.</p>
<p>Assuming the database tables are created by the scheme above, we can proceed to the next step and use NodeUnifiedRDBMapper as baseclass for our mappers. After that we have to implement the methods RDBMapper::getType, NodeRDBMapper::createObject, NodeUnifiedRDBMapper::getTableName, PersistenceMapper::getPkNames, NodeUnifiedRDBMapper::getMyFKColumnNameImpl and NodeUnifiedRDBMapper::getObjectDefinitionImpl. These methods merely ask for properties of the domain class. The example shows the mapper for the table <em>Article</em> mentioned above: </p><pre class="fragment"> class ArticleRDBMapper extends NodeUnifiedRDBMapper
 {
   /**
    * @see RDBMapper::getType()
    */
   function getType()
   {
     return 'Article';
   }
   /**
    * @see NodeRDBMapper::createObject()
    */
   function &amp;createObject($oid=null)
   {
     return new Article($oid);
   }
   /**
    * @see NodeUnifiedRDBMapper::getTableName()
    */
   function getTableName()
   {
     return 'Article';
   }
   /**
    * @see PersistenceMapper::getPkNames()
    */
   function getPkNames()
   {
     return array('id' =&gt; DATATYPE_IGNORE);
   }
   /**
    * @see NodeUnifiedRDBMapper::getMyFKColumnNameImpl()
    */
   function getMyFKColumnNameImpl($parentType)
   {
     // start from the most specific
     if ($this-&gt;getType() == 'Article' &amp;&amp; $parentType == 'Author') return 'fk_author_id';
     if ($parentType == 'Author') return 'fk_author_id';
     return '';
   }
   /**
    * @see NodeUnifiedRDBMapper::getOrderBy()
    */
   function getOrderBy()
   {
     return array();
   }
   /**
    * @see NodeUnifiedRDBMapper::getObjectDefinitionImpl()
    */
   function getObjectDefinitionImpl()
   {
     $nodeDef = array();
     $nodeDef['_properties'] = array
     (
       array('name' =&gt; 'is_searchable', 'value' =&gt; false),
     );
     $nodeDef['_datadef'] = array
     (
      /*
       * Value description:
       */
       array('name' =&gt; 'id', 'app_data_type' =&gt; DATATYPE_IGNORE, 'column_name' =&gt; 'id',
       'db_data_type' =&gt; 'INT(11) NOT NULL', 'default' =&gt; '', 'restrictions_match' =&gt; '', 'restrictions_not_match' =&gt; '',
       'restrictions_description' =&gt; '', 'is_editable' =&gt; false, 'input_type' =&gt; 'text', 'display_type' =&gt; 'text'),
      /*
       * Value description:
       */
       array('name' =&gt; 'fk_author_id', 'app_data_type' =&gt; DATATYPE_IGNORE, 'column_name' =&gt; 'fk_author_id',
       'db_data_type' =&gt; 'INT(11)', 'default' =&gt; '', 'restrictions_match' =&gt; '', 'restrictions_not_match' =&gt; '',
       'restrictions_description' =&gt; '', 'is_editable' =&gt; false, 'input_type' =&gt; 'text', 'display_type' =&gt; 'text'),
     /*
      * Value description:
      */
      array('name' =&gt; 'headline', 'app_data_type' =&gt; DATATYPE_ATTRIBUTE, 'column_name' =&gt; 'headline',
      'db_data_type' =&gt; 'VARCHAR(255)', 'default' =&gt; '', 'restrictions_match' =&gt; '', 'restrictions_not_match' =&gt; '',
      'restrictions_description' =&gt; '', 'is_editable' =&gt; false, 'input_type' =&gt; 'text', 'display_type' =&gt; 'text'),

      ...
     );
     $nodeDef['_ref'] = array
     (
      /*
       * Value description:
       */
       array('name' =&gt; 'author_name', 'ref_type' =&gt; 'Author', 'ref_value' =&gt; 'name', 'ref_table' =&gt; 'Author',
       'id_column' =&gt; 'id', 'fk_columns' =&gt; 'fk_article_id', 'ref_column' =&gt; 'name')
     );
     $nodeDef['_parents'] = array
     (
       array('type' =&gt; 'Author', 'is_navigable' =&gt; false, 'table_name' =&gt; 'Author', 'pk_columns' =&gt; array('id'),
       'fk_columns' =&gt; 'fk_author_id')
     );
     $nodeDef['_children'] = array
     (
       array('type' =&gt; 'Image', 'minOccurs' =&gt; 0, 'maxOccurs' =&gt; 'unbounded', 'aggregation' =&gt; false, 'composition' =&gt; true,
       'is_navigable' =&gt; false, 'table_name' =&gt; 'Image', 'pk_columns' =&gt; array('id'), 'fk_columns' =&gt; 'fk_article_id',
       'order_by' =&gt; array())
     );
     return $nodeDef;
   }
 }
</pre><p>The method NodeUnifiedRDBMapper::getObjectDefinitionImpl is the most important method. It supplies an associative array, in which the attributes of the domain class (<em>_datadef</em>) the parent and the child domain classes (<em>_children</em>) are defined. In addition the Article contains a reference to the name of the Author (<em>_ref</em>), which allows to access the Author without loading it.<br />
Detailed information on the implemetation can be found under NodeUnifiedRDBMapper::getObjectDefinitionImpl.</p>
<p>For configuring the domain classes in the configuration file see <a class="el" href="configuration.html#sectypemapping">[typemapping]</a>.</p>
<h3><a class="anchor" id="howtodomainclass"></a>
Creating the domain classes</h3>
<p>The framework's PersistenceMapper work with the class Node, a subclass of PersistentObject. Different domain classes are created by specifying the type attribute (Node::getType) and a set of attributes (Node::getValueNames). So the class Node is a generic data container, into which data can be put by the method Node::setValue and retrieved by the method Node::getValue. For most applications this will do.</p>
<p>If however more specialized domain classes are required for the application, they must be created by the PersistenceMapper. In this case subclasses of NodeRDBMapper must override the method NodeRDBMapper::createObject, which in turn creates instances of the special domain class.</p>
<h2><a class="anchor" id="howtonode"></a>
Working with the class Node</h2>
<h3><a class="anchor" id="howtoload"></a>
Loading a data structure</h3>
<div class="fragment"><div class="line">$persistenceFacade = &amp;PersistenceFacade::getInstance();</div>
<div class="line"></div>
<div class="line"><span class="comment">// load model</span></div>
<div class="line">$oid = PersistenceFacade::composeOID(array(<span class="stringliteral">&#39;type&#39;</span> =&gt; <span class="stringliteral">&#39;section&#39;</span>, <span class="stringliteral">&#39;id&#39;</span> =&gt; array(<span class="charliteral">&#39;1&#39;</span>)));</div>
<div class="line">$node = &amp;$persistenceFacade-&gt;load($oid, BUILDDEPTH_INFINITE);</div>
<div class="line"><span class="keywordflow">if</span> ($node == null)</div>
<div class="line">  Message::error(<span class="stringliteral">&quot;A Node with object id &quot;</span>.$oid.<span class="stringliteral">&quot; does not exist.&quot;</span>;</div>
</div><!-- fragment --><p>The example loads the section node with id 1 and all children nodes. If the oid of the requested node is not known either use the appropriate methods of PersistenceFacade (e.g. PersistenceFacade::getOID) or in more complex cases do an ObjectQuery.</p>
<h3><a class="anchor" id="howtoiter"></a>
Traversing a data structure</h3>
<div class="fragment"><div class="line">$iterator = <span class="keyword">new</span> NodeIterator($node);</div>
<div class="line"><span class="keywordflow">while</span>(!($iterator-&gt;isEnd()))</div>
<div class="line">{</div>
<div class="line">  $currentObject = &amp;$iterator-&gt;getCurrentObject();</div>
<div class="line">  Message::trace($currentObject-&gt;getOID());</div>
<div class="line">  $iterator-&gt;proceed();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The example outputs the object ids of all nodes that are descendents of $node.</p>
<h3><a class="anchor" id="howtooutput"></a>
Output a data structure into different formats</h3>
<div class="fragment"><div class="line">$iterator = <span class="keyword">new</span> NodeIterator($node);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Output into dot format</span></div>
<div class="line">$filename = <span class="stringliteral">&quot;graph.dot&quot;</span>;</div>
<div class="line">$dotOS = <span class="keyword">new</span> DotOutputStrategy($filename);</div>
<div class="line">$ov = <span class="keyword">new</span> OutputVisitor($dotOS);</div>
<div class="line">$ov-&gt;startIterator($iterator);</div>
<div class="line"></div>
<div class="line">iterator-&gt;reset($node);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Output into XML format</span></div>
<div class="line">$filename = <span class="stringliteral">&quot;graph.xml&quot;</span>;</div>
<div class="line">$xmlOS = <span class="keyword">new</span> XMLOutputStrategy($filename);</div>
<div class="line">$ov-&gt;setOutputStrategy($xmlOS);</div>
<div class="line">$ov-&gt;startIterator($iterator);</div>
</div><!-- fragment --><h3><a class="anchor" id="howtomodify"></a>
Modifying a data structure</h3>
<div class="fragment"><div class="line">$node-&gt;setValue(<span class="stringliteral">&#39;text&#39;</span>, <span class="stringliteral">&#39;hello world!&#39;</span>, DATATYPE_ATTRIBUTE);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Saving changes</span></div>
<div class="line"><span class="comment">// If one node has been modified</span></div>
<div class="line">$node-&gt;save();</div>
<div class="line"></div>
<div class="line"><span class="comment">// If several connected nodes have been modified</span></div>
<div class="line">$iterator = <span class="keyword">new</span> NodeIterator($node);</div>
<div class="line">$cv = <span class="keyword">new</span> CommitVisitor();</div>
<div class="line">$cv-&gt;startIterator($iterator);</div>
</div><!-- fragment --><h2><a class="anchor" id="howtoviews"></a>
Programming the views</h2>
<p>Views are implemented as HTML pages (defined in the view templates), which typically contain a form, which displays the data to be modified. For programming dynamic parts and to access application data the <a href="http://smarty.php.net/" target="_blank">Smarty</a> template language is used.<br />
By default the views are stored as .tpl files in the directory /application/inlcude/views (see <a class="el" href="configuration.html#secsmarty">[smarty]</a>). In the directory /wcmf/application/views those views are stored, which the framework uses for its standard application. These are the basis for the programming of custom views.<br />
 In the view templates all data, which was passed to the view instance is accessible (see <a class="el" href="howtos.html#howtocontroller">Programming the controllers</a>). In the simplest case these can be displayed via <em>{$variable}</em>. In addition object data can be accessed by using <em>{$object-&gt;getValue</em>(...)}. By setting <em>debugView</em> = 1 (see <a class="el" href="configuration.html#seccms">[cms]</a>) in the configuration file Smarty will display the data, which is available in the template, in an external window.<br />
 The data displayed in the view's form is available to the following controller. Some (hidden) input fields should always exist. They are defined in the file /wcmf/application/views/formheader.tpl, which - to simplify matters - should be reused.<br />
For handling the form data some JavaScript functions are provided (and documented) in the file /wcmf/blank/script/common.js.</p>
<p>In the directory /wcmf/lib/presentation/smarty_plugins the framework defines extensions of the Smarty template language:</p>
<ul>
<li>Function <em>translate</em> for localization of strings<br />
 e.g.: {translate text="Logged in as %1% since %2%" r0="$login" r1="$logindate"}</li>
<li>Function <em>sessionvalue</em> to get a session variable<br />
 e.g.: {sessionvalue name="platform"}</li>
<li>Resource <em>lib</em> to integrate templates with a relative path to the framework's root directory (/wcmf)<br />
 e.g.: {include file="lib:application/views/formheader.tpl"}<br />
 ...</li>
</ul>
<h2><a class="anchor" id="howtocontroller"></a>
Programming the controllers</h2>
<p>Controllers execute the user-defined actions. In order to implement custom controllers a class must be derived from the baseclass Controller, which implements the methods Controller::hasView and Controller::executeKernel.</p>
<p>The Request instance passed to the Controller::initialize method provides all data of the preceeding view's input fields to the controller. The names of the input fields are the names of the request values. The controller in turn can pass data to the view by setting them on the Response instance.</p>
<p>The method Controller::hasView returns <em>true</em> or <em>false</em>, whether a view is displayed or not (the return value can differ depending on the context or action, for an example see LoginController).<br />
The method Controller::executeKernel executes the actual action. In this method application data is loaded, modified, created, deleted and where required passed to the view for display or to the next controller to proceed. The method either returns <em>false</em>, which means, that the ActionMapper should call no further controller or true. In the latter case the ActionMapper determines the next controller from the context and action values of the response (see <a class="el" href="configuration.html#actionkey">Action Keys</a>). This means if a view should be displayed, the method must return <em>false</em>.</p>
<p>While programming custom controllers often the methods Controller::initialize and Controller::validate are overridden in order to carry out initializations or to validate provided data.</p>
<p>The framework's controllers are located in the directory /wcmf/application/controller.</p>
<h2><a class="anchor" id="howtoapplication"></a>
Programming the application</h2>
<p>A web application typically consists of several input masks (views), which are used to create, modify and delete data. The application is defined by the actions executable in the individual input masks. Thereby the framework makes no difference between actions used for data handling and those used to navigate or e.g. initiate the export of data.</p>
<p>The definition of an action requires the following steps:</p>
<ol type="1">
<li><a class="el" href="howtos.html#howtoapplication1">Definition of the action name</a></li>
<li><a class="el" href="howtos.html#howtoapplication2">Creating the button to trigger the action</a></li>
<li><a class="el" href="howtos.html#howtoapplication3">Customizing the configuration file</a></li>
<li><a class="el" href="howtos.html#howtoapplication4">Implementing the action as a controller</a></li>
<li><a class="el" href="howtos.html#howtoapplication5">Displaying data in the view</a></li>
</ol>
<p>As an example we use the action for displaying an <em>article</em> node in order to edit it. Let's look at the individual steps:</p>
<h3><a class="anchor" id="howtoapplication1"></a>
Definition of the action name</h3>
<p>We name the action <em>editArticle</em>. This name need not to be unique in the whole application. The ActionMapper only requires the name (and the <a class="el" href="configuration.html#actionkey">Action Keys</a> defined by the action) to find the next appropriate controller.</p>
<h3><a class="anchor" id="howtoapplication2"></a>
Creating the button to trigger the action</h3>
<p>In order to display the data the application must know which article is selected. This is exactly defined by it's <a class="el" href="architecture.html#oid">Object Identifier</a>. The data transfer between the input masks is achieved by the HTTP POST mechanism, i.e. a (hidden) input field must exist, which contains the oid of the article to be displayed. Since for most applications it's often necessary to transfer an oid, the framework defines a standard field <em>oid</em> in each view (see file /wcmf/application/views/formheader.tpl), which can easily be set by the JavaScript function <em>doDisplay</em> (/wcmf/blank/script/common.js).</p>
<p>The action is triggered upon submission of the input form. Another JavaScript function (<em>submitAction</em>) simplifies the execution. The form data is passed to the main.php script, which delegates the further execution to the ActionMapper. The link to execute the action could look like this: </p><pre class="fragment">&lt;a href="javascript:setContext('article'); doDisplay('{$article-&gt;getOID()}');
              submitAction('editArticle');"&gt;{translate text="edit"}&lt;/a&gt; </pre><p> For details on programming the views see <a class="el" href="howtos.html#howtoviews">Programming the views</a>.</p>
<h3><a class="anchor" id="howtoapplication3"></a>
Customizing the configuration file</h3>
<p>To determine the controller, which carries out the action, the ActionMapper requires an appropriate entry in the configuration file (see <a class="el" href="configuration.html#secactionmapping">[actionmapping]</a>). If the controllers name is <em>ArticleController</em>, the entry could look like this: </p><pre class="fragment"> [actionmapping]
 ??editArticle = ArticleController
</pre><p> Don't forget to introduce the ArticleController in the configuration section <a class="el" href="configuration.html#secclassmapping">[classmapping]</a>.</p>
<p>Additionally the ArticleController should display a view for editing the article. If we name this view <em>article.tpl</em>, the configuration entry would look like the following (see <a class="el" href="configuration.html#secviews">[views]</a>): </p><pre class="fragment"> [views]
  ArticleController?? = article.tpl
</pre><h3><a class="anchor" id="howtoapplication4"></a>
Implementing the action as a controller</h3>
<p>The action is executed in the controller - in this example in the <em>ArticleController</em> class. Since the controller should display a view with the article's data, we first must specify that the controller has a view and second the data of the article must be passed to the view.<br />
At first however it must be assured, that the controller receives an oid. This happens in the method Controller::validate, which searches for the entry in the passed data: </p><pre class="fragment"> function validate()
 {
   if ($this-&gt;_request-&gt;getValue('oid') == '')
   {
     $this-&gt;setErrorMsg("No 'oid' given in data.");
     return false;
   }
   return true;
 }
</pre><p>We declare the existence of a view in the method Controller::hasView: </p><pre class="fragment"> function hasView()
 {
   return true;
 }
</pre><p>Finally the action is executed in the method <em>Controller::executeKernel</em>. Here the controller loads the data and provides it to the view for display by setting it on the response instance: </p><pre class="fragment"> function executeKernel()
 {
   $persistenceFacade = &amp;PersistenceFacade::getInstance();

   // load model
   $article = &amp;$persistenceFacade-&gt;load($this-&gt;_request-&gt;getValue('oid'), BUILDDEPTH_INFINITE);

   // assign model to view
   $this-&gt;_response-&gt;setValue('article', $article);

   // stop processing chain
   return false;
 }
</pre><p>It's important that the method returns false, since this causes the ActionMapper to end the execution and wait for user input. The display of the view is done by the framework.</p>
<h3><a class="anchor" id="howtoapplication5"></a>
Displaying data in the view</h3>
<p>After the controller has provided the view with the data, the view can display the data. In our case after the ArticleController has been executed a variable <em>article</em> is known to the view, which matches the article node.<br />
The programming of the views is done in HTML together with the Smarty template language. The file <em>article.tpl</em> could contain the following line: </p><pre class="fragment">article name: {$nodeUtil-&gt;getInputControl($article, "name")} </pre><p>In the curly brackets you can find Smarty code, which calls the method NodeUtil::getInputControl. This method displays the input control (in our case a textfield), which corresponds to the article's <em>name</em> attribute, in the HTML page. In the same manner the other attributes can be handled.</p>
<h2><a class="anchor" id="howtorights"></a>
Rights management</h2>
<p>Rights can be assigned to the execution of actions in the user interface or to the editing of domain classes and individual objects (instances of domain classes). For editing content the framework defines the rights <em>read</em>, <em>modify</em>, <em>delete</em> and <em>create</em>.<br />
The authorization for actions in the user interface is handled by the ActionMapper, for actions concerning the data the PersistenceMapper checks the permissions (and sets objects, for which the right <em>modify</em> is not set, to non-editable (<em>is_editable</em> = false) ). Both classes use the method RightsManager::authorize and generate a fatal error message, if authorization fails (see <a class="el" href="howtos.html#howtoerror">Error handling</a>). To prevent this the rights can be retrieved directly in order to take appropriate messures: </p><pre class="fragment"> $rightsManager = &amp;RightsManager::getInstance();
 if ($rightsManager-&gt;authorize($this-&gt;_request-&gt;getValue('oid'), '', ACTION_READ))
 {
   $object = &amp;$persistenceFacade-&gt;load($this-&gt;_request-&gt;getValue('oid'), BUILDDEPTH_INFINITE);
 }
 else
 {
   // do something else if the user cannot read the object
 }
</pre><p>In the example the object is only loaded, if it's permitted. For the definition of rights see <a class="el" href="configuration.html#secauthorization">[authorization]</a>. </p><dl class="section note"><dt>Note</dt><dd>If <em>anonymous</em> is set to one in the configuration file, the rights management is disabled (see <a class="el" href="configuration.html#seccms">[cms]</a>).</dd></dl>
<h2><a class="anchor" id="howtoconcurrency"></a>
Concurrency</h2>
<p>If more than one user works with the application at the same time, conflicts can occur, if two users want to edit the same object concurrently. In this case the first user can request a lock on that object, which only allows reading access to succeeding users. This lock will be transfered to all instances loaded in the future as long until the user unlocks the object, which happens automatically upon execution of an action (call to main.php). In the sourcecode this looks as follows: </p><pre class="fragment"> $lockManager = &amp;LockManager::getInstance();
 $object = &amp;$persistenceFacade-&gt;load($this-&gt;_request-&gt;getValue('oid'), BUILDDEPTH_INFINITE);

 // if the object is locked by another user we retrieve the lock to show a message
 $lock = $object-&gt;getLock();
 if ($lock != null)
 {
   $lockMsg .= $lockManager-&gt;getLockMessage($lock, $recipe-&gt;getName());
 }
 else
 {
   // try to lock object
   $lockManager-&gt;aquireLock($this-&gt;_request-&gt;getValue('oid'));
 }
</pre><p>The functionality described above is imlemented in the method LockManager::handleLocking, with the only difference that this method only acquires a lock in cases in which the user is allowed to modify the object.<br />
An object, which is loaded by another user is set to non-editable (<em>is_editable</em> = false) automatically upon loading.</p>
<h2><a class="anchor" id="howtoi18n"></a>
Multilanguage Support</h2>
<p>For localization of the application the method Message::get is provided. For a given (english) string this method searches for the required language's version. The language version can either be passed directly with the method call or can be set application wide (see documentation of Message::get).<br />
How the translation is retrieved depends on the parameter <em>usegettext</em> (see <a class="el" href="configuration.html#seccms">[cms]</a>). If it is set to 1, the method uses the PHP function <em>gettext</em>. This in turn makes use of .mo files in the directory /localeDir/language/LC_MESSAGES - e.g. /locale/de_DE/LC_MESSAGES/main.mo (see documentation of gettext).<br />
If gettext doesn't exist, the language version can also be taken from an associative array named messages_language (e.g. messages_de_DE). This must be defined in a file /localeDir/language/LC_MESSAGES/messages_language.php (e.g. /locale/de_DE/LC_MESSAGES/messages_de_DE.php). The keys of the array are the strings, which are passed to the method Message::get, the values are the corresponding translations.<br />
</p><dl class="section note"><dt>Note</dt><dd>If a translation for a text doesn't exist, the string, which was passed to the method Message::get, will be used.</dd></dl>
<p>For making the localization more comfortable some tools are provided in the directory /wcmf/tools/i18n:</p><ul>
<li><em>locale.php</em> extracts all strings to be localized (where the method Message::get is used) from the application (views, controllers) and creates a *.po file for use with gettext.</li>
<li><em>po2array.php</em> generates the array definition described above from a *.po file.</li>
</ul>
<p>For localizing the view templates a Smarty plugin is provided, which is to be used as follows: </p><pre class="fragment">{translate text="Logged in as %1%" r0=$authUser-&gt;getLogin()} </pre><p>The <em>parameters</em> of the method Message::get are defined by the values of <em>r0</em>, <em>r1</em>, ...</p>
<h2><a class="anchor" id="howtologdebug"></a>
Debugging/Logging</h2>
<p>For debugging und logging output the <a href="http://logging.apache.org/log4php/" target="_blank">log4php</a> framework is used. For convenient usage wCMF defines a thin wrapper class called Log. To log a debug message in the category of the current class, just call:</p>
<pre class="fragment">Log::debug($message, __CLASS__); </pre><h2><a class="anchor" id="howtoerror"></a>
Error handling</h2>
<p>In the application two types of errors are distinguished:</p><ul>
<li><em>Fatal:</em> Errors, which are so critical, that it's not possible to proceed with the current action (e.g. the missing of a controller).</li>
<li><em>Non-fatal</em>: Errors, which merely demand a notification to the user (e.g. invalid input)</li>
</ul>
<p>These errors can be produced in the following ways:</p>
<ul>
<li><em>Fatal:</em> The use of WCMFException::throwEx calls a global error handling routine: <div class="fragment"><div class="line">onError($message, $file=<span class="stringliteral">&#39;&#39;</span>, $line=<span class="stringliteral">&#39;&#39;</span>) </div>
</div><!-- fragment --></li>
<li><em>Non-fatal</em>: adding a message by calling Controller::appendErrorMsg makes this message - together with all accumulated messages before and those to follow - available in the next view's <em>$errorMsg</em> variable.<br />
 In order to delete old messages the method Controller::setErrorMsg class must be called with an empty string parameter.</li>
</ul>
<p>Many classes define a method <em>getErrorMsg</em>, which provides more detailed information on the cause of an error. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr>
<footer>
  <div class="container">
    <div class="row">
      <div class="col-md-9">
        <p>&copy; 2014 <a href="http://www.wemove.com" target="_blank">wemove digital solutions</a><br>
          Generated on Tue Aug 26 2014 02:48:59 for wCMF by &#160;<a href="http://www.doxygen.org/index.html" target="_blank">doxygen</a> 1.8.7</p>
      </div>
    </div>
  </div>
</footer>
</body>
</html>
